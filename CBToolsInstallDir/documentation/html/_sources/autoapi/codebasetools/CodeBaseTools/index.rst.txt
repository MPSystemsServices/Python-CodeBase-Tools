:mod:`codebasetools.CodeBaseTools`
==================================

.. py:module:: codebasetools.CodeBaseTools

.. autoapi-nested-parse::

   -------------------------------------------
   CodeBaseTools Database Management Made Easy
   -------------------------------------------

   The CodeBaseTools module is a wrapper and Pythonizer for the CodeBasePYWrapperXX.pyd shared library, which in
   turn is built on the codebase 'C' DLL library.  This provides data management and persistence capability using
   .DBF style data tables and sophisticated data management features including record locking, powerful indexing,
   and a full suite of data retrieval capabiliies.

   The Python .pyd module,written in 'C' using the Python 'C' API, which provides relatively easy and Pythonic access
   to Visual FoxPro DBF tables.  The underlying engine is the CodeBase library, which, as of September 28, 2018, is
   released by its owner Sequiter, Inc., into Open Source, and is available for free use under the GNU Lesser GPL
   V3.0 license.

   Basic documentation for each function is provided in the docstrings below.

   NOTE FOR THIS VERSION 2.05 -- December, 2020:
   This version is a wrapper for a compiled core python module named CodeBasePYWrapperXX.pyd which is a revised and
   improved version of the original CodeBaseWrapper.dll.  The core module is now built with the Python C-API which
   allows much faster transfer of data from disk to memory.  The original dll was accessed using the cTypes modules
   and the Win32 extensions.  cTypes is not required for this enhanced version.  Each version of Python requires
   its own unique compilation of the underlying c API code.  These are identified by the last two digits of the file
   name.  The Python source in this file detects the currently running version of Python and loads the appropriate
   version of the .pyd file.

   Python Version information:
   ---------------------------
   As of this release, this version is compatible and has been tested ONLY with 32-bit versions of Python.  This is
   due to the fact that the 64-bit version of CodeBase is still being tested and has not yet been released to Open
   Source.

   This module has been developed and tested with 2.7.17, 3.6, 3.7, 3.8, and 3.9.1.

   Versions prior to 2.7 may or may not work and are not supported.  Note that some sub-versions of Python 3.8 have
   problems in the implementation of the C API which may result in unstable behavior.  Version 3.9.1 is recommended.

   Since each version of Python has its own version of the API, there is a separate, but functionally identical
   version of CodeBasePYWrapperXX.pyd for each Python version supported.  This module imports the version
   appropriate to the Python version running.  All versions of this .pyd file are installed with this module and the
   CodeBaseTools module imports the correct one based on the version of Python you are running.

   Currently, this module supports Python versions: 2.7, 3.6, 3.7, 3.8, and 3.9.

   String handling for Python 2/3 compatibility
   .............................................
   Effective with the April, 2018 changes for Python 2 and 3 compatibility, all text values passed to the
   Codebase Tools engine will be coerced to str types.  That means plain strings for 2.x and Unicode
   strings for 3.x.  The engine will test for these types and throw an error if the type is wrong.
   This applies to path names (no "pathlike" objects), alias names, field names, tag names, and logical expressions
   for selecting and filtering.

   Field return values will be converted per the table below, if conversion is requested.  Unconverted field
   contents will be returned as type bytes in all versions, if stored in the tables as text.  Field setting values may
   be supplied as any valid type (including text representations of values like numbers and dates) and will be converted
   by the engine.

   FoxPro and Visual FoxPro Compatibility and Field Type definitions used.
   .......................................................................
   All field types used in FoxPro 2.6 DOS and Windows are supported natively by this tool.  Also the indexes
   generated are compatible with .CDX compound indexes with one or more index tags.

   Visual FoxPro 5.0 through 9.0 SP2 tables are supported with the following exceptions:

   1. Tables contained in a database container can be read, written to and reindexed, but only the short field names
      will be usable.  Field names that are 10 characters long or less can be accessed by their normal names.
   2. Tables contained in a database container cannot have their structure changed, nor have indexes removed, added,
      or changed, as those changes will not be recorded in the database container.
   3. VFP supports multiple Windows Code Pages, including 1252, Western Europe.  This module only supports
      tables marked for Code Page 1252, however, NO translations between code pages are performed by this module.
   4. VFP may or may not support Unicode strings, including multibyte languages like Cantonese, in its C and M type
      fields.  See the docs below on string and Unicode handling in this module.
   5. Most, but not all field types are supported, and some type codes are different as given in the following table:

   +------+---------------------+----------------------+-------------------+------------------+
   |VFP   | Type Name           | CodeBase Type        |  Python 2.x       |  Python 3.x      |
   |Type  |                     |                      |  Type             |  Type            |
   +======+=====================+======================+===================+==================+
   |  B   |  Double             |  B                   |  float            |   float          |
   +------+---------------------+----------------------+-------------------+------------------+
   |  C   |  Character          |  C                   |  str              |   str (Unicode)  |
   +------+---------------------+----------------------+-------------------+------------------+
   |  C   |  Character(bin)     |  Z                   |  bytearray (3)    |   bytes or str   |
   +------+---------------------+----------------------+-------------------+------------------+
   |  D   |  Date               |  D                   |  datetime.date    |   datetime.date  |
   +------+---------------------+----------------------+-------------------+------------------+
   |  F   |  Float              |  F (same as Numeric) |  float            |   float          |
   +------+---------------------+----------------------+-------------------+------------------+
   |  G   |  General            |  G (see note 2 below)|  bytes            |   bytes          |
   +------+---------------------+----------------------+-------------------+------------------+
   |  I   |  Integer            |  I                   |  int              |   int            |
   +------+---------------------+----------------------+-------------------+------------------+
   |  I   |  Integer(auto incr) |  N/A see note)       |                   |                  |
   +------+---------------------+----------------------+-------------------+------------------+
   |  L   |  Logical            |  L                   |  bool             |   bool           |
   +------+---------------------+----------------------+-------------------+------------------+
   |  M   |  Memo               |  M                   |  str              |   str (Unicode)  |
   +------+---------------------+----------------------+-------------------+------------------+
   |  M   |  Memo(binary)       |  X                   |  bytes            |   bytes          |
   +------+---------------------+----------------------+-------------------+------------------+
   |  N   |  Number             |  N                   |  float            |   float          |
   +------+---------------------+----------------------+-------------------+------------------+
   |  Q   |  Varbinary          |  [not supported]     |                   |                  |
   +------+---------------------+----------------------+-------------------+------------------+
   |  T   |  Datetime           |  T                   |  datetime         |   datetime       |
   +------+---------------------+----------------------+-------------------+------------------+
   |  V   |  Varchar            |  [not supported]     |                   |                  |
   +------+---------------------+----------------------+-------------------+------------------+
   |  V   |  Varchar(binary)    |  [not supported]     |                   |                  |
   +------+---------------------+----------------------+-------------------+------------------+
   |  W   |  Blob               |  [not supported]     |                   |                  |
   +------+---------------------+----------------------+-------------------+------------------+
   |  Y   |  Currency           |  Y                   |  Decimal          |   Decimal        |
   +------+---------------------+----------------------+-------------------+------------------+

   Note 1 -- The last Codebase version added support for an auto incrementing integer field, but these fields are NOT
   recognized by Visual FoxPro, and VFP auto incrementing integer fields are not recognized by Codebase and can
   cause Codebase to crash.  This module therefore does not support auto incrementing integer fields directly, but a
   utility function getNewKey() is provided as a source for consecutive integer values.

   Note 2 -- CodeBase and this module support G (General) type fields for reading and writing, but unlike in Visual
   Foxpro, their contents cannot be filled with some kind of APPEND GENERAL sort of function.  VFP tables which have
   had a G field populated by the APPEND GENERAL command from an OLE document can be copied to other tables by this
   module, however, as these fields are read as simple strings of generic binary data (possibly containing null bytes),
   exactly as X Memo(binary) fields, there is no interpretation done with them.

   Note 3 -- All "strings" in Python 3.x are Unicode.  Sequences of bytes that are not intended to represent text of any
   kind are stored in "bytes" variables, not "strings".  Accordingly, for Py 3.x the default Python type target for a
   standard char or memo field is a string, and that of char or memo binary fields is bytes.  But you may want to store
   Unicode data in binary fields to ensure no CodePage conversions are attempted by FoxPro.  As a result options are
   provided to write to and read from binary fields in several different Unicode codings.

   String handling and internationalization... Depends on Python Version
   .....................................................................
   Field Names:
       ASCII is default, but extended ASCII with Code Page 1252 is supported for displaying table structure,
       but fields having names with characters above ASCII 127 cannot be accessed for reading and writing.
   Tag Names:
       ASCII is default, but extended ASCII tag names work properly

   Alias Names:
       Must be standard ASCII strings.  If specified with cp1252 high order bit characters, the Alias Name will be
       coerced to 7-bit ASCII.

   Table Names:
       Names supported by the operating system will work (but see note above for Alias Names, as auto-assigned
       Alias Names are also forced to 7-bit ASCII strings.)

   Data Fields:
   ------------
   Python 2.7 (earlier versions may work but are not officially supported)
   .......................................................................
   Char and Memo:
       Default data storage is 8-bit strings as found in Python str objects.  Embedded nulls will be treated as end of
       string markers and will not be stored.  Unicode strings will be coerced to Code Page 1252 before saving.
       Applies to scatter, gather, insert, replace, and curval type functions.

       If bytearray types (with or without embedded nulls) are supplied for these fields, they will be copied into
       the target field as pure binary data.  In the case of char fields, any unused space to the right of the data
       will be padded with blanks.  Memo fields will contain only the data content.  If you write binary data from
       bytearray objects into these standard text fields, be sure that you handle the content accordingly when
       reading it back.  Also beware of FoxPro Code Page translations to which these fields are subject by default.

       The following special coding will be allowed optionally in these functions for string and unicode object
       data sources.:
       - ' ', 'X', or None = The default storage and retrieval
       - 'W' = Windows Double Byte Unicode encoding for the specified Code Page (default Code Page in the U.S.A. is
       usually cp1252) on the local machine.  Source data may be string or bytearray, and conversion will be
       performed.  Unicode will be coerced to the default Code Page.
       - '8' = UTF-8 encoding. Source may be string, bytearray, or Unicode.

   Char(binary) and Memo(binary):
       Default data storage is a non-text sequence of 8-bit bytes with no textual meaning.  The raw contents of strings
       will be stored, but with strings terminated when a NULL is encountered.  Bytearrays will be copied character
       for character, regardless of the presence of null bytes.

       The following special coding will be allowed optionally in these functions with string or unicode type
       data source objects:
       - ' ', 'X', or None = The default storage and retrieval
       - 'D' = Windows Double Byte Unicode encoding for the specified Code Page (default Code Page in the U.S.A. is
       usually cp1252) on the local machine.
       - 'U' = UTF-8 encoding.
       - 'C' = Custom Code Page code.  See Python codecs documentation for allowable values.  Examples include:
       "cp1252" - Western Europe, "cp1251" - Cyrillic (Russian, etc.), "gb2312" - Simplified Chinese.

   Python 3.x (3.6 and higher.  Earlier 3.x versions not supported.)
   ..................................................................
   Char and Memo:
       All 3.x Python strings are Unicode.  This module will attempt to code Python strings for storage in the
       field type specified.  If the Unicode string value cannot be converted into a form suitable for the field type,
       an error will be triggered. Applies to scatter, gather, insert, replace, and curval type functions.
       By default conversion of the strings to and from 8-bit Code Page 1252 will be attempted.  This will handle
       most special characters for Western European languages.

       Version 3.x also has a bytes and bytearray type (differences are very subtle, but the both contain
       sequences of bytes that don't necessarily have avy textual meaning.  Both of these binary data types may be
       stored in both plain and binary char/memo fields, but you will need to be careful with their data
       retrieval.  In all such cases, the contents of the bytes and bytearray objects will be stored byte for
       byte into the target field.

       The following special coding will be allowed optionally in these functions:
       - ' ', 'X', or None = The default storage and retrieval (cp1252, 8-bit coding or plain ASCII)
       - 'W' = Windows Double Byte Unicode encoding for the specified Code Page (default Code Page in the U.S.A. is
       usually cp1252) on the local machine.
       - '8' = UTF-8 encoding.

   Char(binary) and Memo(binary):
       Default data storage is a non-text sequence of 8-bit bytes with no textual meaning.
       The following special coding will be allowed optionally in these functions:
       - ' ', 'X', or None = The default storage and retrieval.  For Bytes and ByteArray data, this will be a simple
       copy of the binary data.  Char fields will be filled out with nulls.  String (Unicode) data will be stored
       as Code Page 1252 and padded out with blanks. (For pure binary data, memo (binary) should be preferred.)
       - 'D' = Windows Double Byte Unicode encoding for the specified Code Page (default Code Page in the U.S.A. is
       usually cp1252) on the local machine.
       - 'U' = UTF-8 encoding.
       - 'C' = Custom Code Page code.  See Python codecs documentation for allowable values.  Examples include:
       "cp1252" - Western Europe, "cp1251" - Cyrillic (Russian, etc.), "gb2312" - Simplified Chinese.  There
       are many others.

   All Python versions
   -------------------
   Note that with all the non-default codings, you are expected to know what codings are contained the fields
   you are reading and writing.  Data which cannot be transformed by the Python codecs manager will trigger
   a Python error and will need to be trapped by a try... except... block.

   Note that if you specify a custom coding and are sharing the data with Visual FoxPro, you are responsible for
   ensuring the codings match on both sides.  VFP will dynamically change field data in Char and Memo
   fields (but not their binary versiona) if the table and local machine Code Pages do not match.  This could
   result in badly corrupted data, as this module does no automatic Code Page conversions.

   Also, be careful with functions that read or write data from and to multiple fields.  In such cases, the custom
   coding spcifiers shown above will be applied to every field of the appropriate type.  If that is not what you
   want, process fields individually using replace() or curvalstrex().


   Table size and other limitations when using CodeBase.  Breaking the xBase 2GB barrier.
   ----------------------------------------------------------------------------------------
   Visual FoxPro and other commercial xBase applications were limited by their 32-bit architecture to
   tables no larger than 2GB in size and a maximum of 1GB records.  Typically, as tables approached this
   limit, performance began to degrade considerably.  Other limits of VFP were as follows:
   - Maximum size of a char field: 254 bytes
   - Maximum size of a table record (total size of all fields): 64K
   - Maximum size of a field name: 10 ASCII characters
   - Maximum number of fields per record: 255
   - Maximum size of an index key value: 240 bytes
   - Maximum size of an entry in a memo field: 1GB

   The default limitations of CodeBaseTools tracks these limits in order to maintain compatibility with tables
   accessed concurrently by VFP applications.  HOWEVER, the Large Table Option in CodeBaseTools allows you
   to build tables far exceeding these limitations.  In the process, however, you give up some compatibility
   with VFP applications.  (Even without the Large Table Option, CodeBase supports somewhat higher limits than
   VFP.  See the CodeBase documentation for details.  But tables which exceed the VFP limits cannot be safely
   shared with VFP applications or their derivatives.)

   An instance of CodeBaseTools may be either Large Table OR standard table.  Both cannot be in effect at the
   same time.  To launch CodeBaseTools with Large Table mode turned ON, set the parameter for Large Mode to
   true thus:
   'oCBT = CodeBaseTools.cbTools(True)'

   With Large Table mode set to True, the following limits apply:
   - Maximum size of one table: Over 4000TB
   - Maximum memo file size: 130TB
   - Maximum size of one entry in a memo field: 4GB
   - Maximum size of a char field: 64K bytes
   - Maximum size of a single record (all fields): 2GB
   - Maximum number fields per record: 2046
   - Maximum size of a field name: 10 ASCII characters

   According to the CodeBase documentation, tables smaller than 2GB and otherwise within the VFP limits can be shared
   with VFP using the Large Table Mode, but once a table grows beyond the VFP limits, VFP will be unable to access the
   table, and in the process of trying may corrupt it.  Beware.

   ------------------------------------------------------------------------------------------------------------------------



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   codebasetools.CodeBaseTools.VFPFIELD
   codebasetools.CodeBaseTools._cbTools
   codebasetools.CodeBaseTools.TableObj



Functions
~~~~~~~~~

.. autoapisummary::

   codebasetools.CodeBaseTools.cbTools
   codebasetools.CodeBaseTools.cbToolsX
   codebasetools.CodeBaseTools.copydatatable


.. py:class:: VFPFIELD

   Bases: :class:`object`

   This is a simple quasi-structure class that contains attributes for all properties required for creating a field
   in a CodeBaseTools .DBF table.  When interrogating a .DBF table to retrieve information about its field
   structure, CodeBaseTools returns a list of object references to VFPFIELD objects for each field.

   .. attribute:: cName

      The text string of the field name.  Typically upper case and a maximum of 10 characters in length        Must start with a letter or underscore and may contain only alphanumeric characters and underscores.

   .. attribute:: cType

      The CodeBase letter code for the type of field.  See the topic FoxPro and Visual FoxPro Compatibility        and Field Type definitions used for a table of codes and types.

   .. attribute:: nWidth

      The width of the field.  This is used for character fields (type 'C') and number fields (type 'N').        For character fields, this is the fixed width of the field in bytes.  If you'll be storing Unicode data        which may have multi-byte values, be sure to allow enough room.  For number fields, this specifies the        total number of digits to make room for.  For example if the largest value you expect to store in the field        is 999.99, then you should set the width to 6 to provide room for digits on both sides of the decimal point        AND for the decimal point itself.

   .. attribute:: nDecimals

      Used for number fields (type 'N'), this specifies how many digits to the right of the decimal        point to allow for.  May be 0.  Not required for integer type fields.  Where not relevant, defaults        to 0.

   .. attribute:: bNulls

      By default, .DBF table fields may not take on a value of NULL ('None' in Python code).  NULL in        .DBF terminology is truly "unknown".  However, if a data field must be able to store a value of NULL,        then set this value to True.


.. py:class:: _cbTools(bLargeMode=False)

   Bases: :class:`object`

   The _cbTools class is the heart of the CodeBaseTools module.  It provides a very wide range of tools for creating,
   analyzing, sorting, manipulating, and otherwise processing data stored in convenient, easily transported and shared
   .DBF data tables.  Normally, you will not create instances of _cbTools() directly, but will use the cbTools() and/or
   cbToolsX() functions in this module to produce instances of this object class.

   .. attribute:: recDict
      

      

   .. attribute:: recArray
      

      

   .. attribute:: _tablenames
      

      

   .. method:: __getitem__(self, xfile)


   .. method:: __del__(self)


   .. method:: cb_shutdown(self)

      Manually does what the __del__() does above.


   .. method:: TableObj(self, *args, **kwargs)

      Create data table object from cbTools connection object.

      This provides for an alternative interface to tables that some may consider to be more Pythonic        than the declarative VFP approach which is used by default.  In the default VFP mode, you create an instance        of CodeBaseTools and open the table and obtain a dict() of the first (TOP) record, as below:

      Example:
      ::
          import CodeBaseTools
          oCBT = CodeBaseTools.cbTools()
          bResult = oCBT.use(r"c:\somepath\sometable.dbf", alias="SOMETABLE")
          if bResult:
             oCBT.select("SOMETABLE")
             # select() is optional, unless you have opened other tables in the code since the use()
             oCBT.goto("TOP")
             xRec = oCBT.scatter()
             # To access one field'
             print(xRec["MYFIELDNAM"])
          oCBT.closetable("SOMETABLE")
          # the Alias parameter is not strictly required, but is good practice.

      In this default mode above, you operate on tables by selecting the appropriate work area (a.k.a. Alias name)        and then call functions to manipulate the data in the table(s) you currently have open.

      Alternatively you can create table objects and call methods of those objects.  You access the values        of the fields for the "current record" using properties with the same name as the fields.  The above example        would be coded like this:

      Example:
      ::
          import CodeBaseTools
          oCBT = CodeBaseTools.cbTools()
          oMyTable = oCBT.TableObj(r"c:\somepath\sometable.dbf")
          oMyTable.goto("TOP")
          xRec = oMyTable.scatter()
          # to access one field
          print(oMyTable.myfieldnam)
          oMyTable.closetable()'

      Some things to consider:
          - In the table object mode, set deleted status is set to True at creation.  You should              test the performance of the deleted() assignment if you decide to change that in your use              of this approach.

          - The property names used to obtain the field values for the current record are NOT case sensitive.              If there is no current record, the value of all properties will be None.  Since None may be a valid              value for a field, you should check the value of the cErrorMessage property to determine if there              really is no record there.

          - In the table object mode, as with the default mode, you can open a table multiple times              with different alias values.  Each table behaves separately relative to current record              and index settings.  However, you MUST specify a unique alias value in the TableObj() function              call.
            Example:
            ::
               oMyTable = oCBT.TableObj(r"c:\somepath\sometable.dbf", alias="MYNEWALIAS")

          - Some cbTools() functions like flush() and locate() may not work as expected. Test, Test, Test.

          - Deleting the variable containing the table object name or setting its value to None does NOT              close the table.  You MUST remember to issue a close() or closetable() method to force the              table closed before destroying the object.  This must be done for each of any multiple instances              of the table object you have created.  The isexclusive() method may report incorrect results              if called on one of these objects.

          - Users of this module are invited to explore extensions and enhancements to the TableObj()              mode, as the maintainer is not actively working on it.

          - There is currently no way to open a table exclusive with the TableObj() method.  This can              make applying indexes problematic if multiple users might have access to a table.  Unlike              Visual FoxPro, CodeBase will allow table indexing and re-indexing even if not opened exclusively.              CodeBaseTools likewise allows it.  But be sure to test for error messages when reindexing,              as error conditions may be reported if another process has the index file open.
          - Calling any method on the table object will set the currently selected table to the table              you are referencing.  If you are using a mix of the table object approach and the default              approach be aware that the "currently selected" table may not be what you expect after any              of the table objects are accessed.

          - You can mix the object and default versions (but do so carefully and test carefully).  For example,
            you can do this:
            ::
              oCBT.select("SOMETABLE")
              # optional, unless you have opened other tables in the code since the use()
              oCBT.goto("TOP")
              xRec = oCBT.scatter()
              # To access one field
              print(xRec["MYFIELDNAM"])
              oSomeTable = oCBT.TableObject("SOMETABLE")
              # Note use of the alias as the parameter.
              print(oSomeTable.myfieldnam)
              oSomeTable.dispstru()  # Writes the structure text to stdout
              oCBT.closetable("SOMETABLE")
              # the Alias parameter is not strictly required, but is good practice.

          - Finally, test your applications thoroughly if you are using the TableObj() mode, to make              sure that all functions you are using work correctly in this mode.  We make no guarantees.

      :param tablename: should include full path name of table to open OR an alias of a table already open.
      :param others: you can optionally pass named parameters like 'readOnly' found in the use() method.
      :param reset: will cause file to be re-opened if already open.

      :returns: A table object for use in subsequent access to the table and its records.


   .. method:: setcustomencoding(self, lpcEncoding='')

      If you want string data to be retrieved and saved in an encoding different from the three basic options
      (ASCII, UTF-8, and Code Page 1252), you can specify one the many standard Python encodings (see the Python
      documentation for the latest complete list.)  For this custom configuration to be applied, the conversion
      code of 'C' must be specified and the target field must be a binary version (either of char or memo).
      :param lpcEncoding: Python encoding name like "cp1252" or "cp1251".
      :return: True.  Note that there is no error checking on the value of the lpcEncoding parameter!  If
      you specify a non-existent name, this module will generate a coding error when processing binary data
      with the 'C' conversion option.

      See the Class documentation (doc-string) for specifics on the available encoding values for string
      and binary values.  Note that while these values may be set in Py 2.x applications, their primary
      use is in Py 3.x applications where all strings are Unicode.


   .. method:: setdateformat(self, lpcFormat='')

      Codebase, like the USA versions of Visual FoxPro assumes U.S. standard date
      expressions of the form MM/DD/YY or MM/DD/YYYY, in contrast to other parts of
      the world that use DD/MM/YY or DD/MM/YYYY or other combinations.  This default
      assumptions about date text strings can be changed.  This is especially useful
      when importing text data via the appendfrom() function.  If non-numeric
      characters are found in the text, and it is intended to be stored in a date or
      datetime field, then an attempt will be made to parse the text based on the
      standard date expression, either MM/DD/YYYY or an alternate set prior to the
      append process.

      :param lpcFormat: This must be a character string with at minimum the characters            'YY' or 'YYYY', and 'MM', and 'DD' in some combination with punctuation.            The empty string or None restores the MDY/AMERICAN default. Alternatively             it must be one of the Visual FoxPro standard SET DATE TO values such as:

                        - AMERICAN = MM/DD/YY
                        - ANSI = YY.MM.DD
                        - BRITISH = DD/MM/YY
                        - FRENCH = DD/MM/YY
                        - GERMAN = DD.MM.YY
                        - ITALIAN = DD-MM-YY
                        - JAPAN = YY/MM/DD
                        - TAIWAN = YY/MM/DD
                        - USA = MM-DD-YY
                        - MDY = MM/DD/YY
                        - DMY = DD/MM/YY
                        - YMD = YY/MM/DD

      :returns: 1 on OK, 0 on any kind of error, mainly unrecognized formats.

      NOTE: The total length of the lcFormat string must be no greater than 16 bytes.


   .. method:: getdateformat(self)

      Obtains the current setting of date format from the CodeBase engine.  Returns a text string indicting
      the type of format. See setdateformat() for format codes.  Will always return a string value.


   .. method:: newfield(self, cName, cType, nWidth, nDecimals, bNulls=False)

      Factory method that create a new instance of the VFPFIELD object with properties set by the
      parameters.  To create a new table, one option is to create each field object using this function
      and append the result into a list().  That resulting list can be passed to createtable() to
      build the desired table.
      :param cName: Text string up to 10 characters.  May NOT begin with a number or a punctuation character
      :param cType: One of the allowed field type codes such as 'C' for character, 'N' for numeric, etc.
      :param nWidth: Width of a char ('C') field or 'N' field.  Set to 0 when not relevant.
      :param nDecimals: Used only for Number fields.  Set to 0 otherwise
      :param bNulls: If True, then the field will allow the value of .NULL. or None (in Python terms).
      :return: The field object.  NO ERROR CHECING IS PERFORMED!


   .. method:: isexclusive(self)

      Returns the exclusive open status on the currently selected table.  Returns True if exclusive, False if
      NOT exclusive.  Returns None on error.


   .. method:: islargemode(self)

      Returns the status of Large Mode operations.  If this instance of the Tools is using large mode
      then, this will return True.  Otherwise False.  If True, this tools instance may NOT be used to
      open DBF tables that might also be opened concurrently by Visual FoxPro applications.

      See the Class DocString for details on the difference between default mode and Large Table Mode
      limits on table size and other properties.


   .. method:: use(self, tableName, alias='', readOnly=False, exclusive=False, noBuffering=False)

      Basic method for starting work with a DBF table using the default declaratory mode.  See
      the TableObj() method for the alternate object-oriented method and its limitations.

      This method must be called before any work with
      the table can be performed. After the table is opened with use(), it is the "Currently
      Selected Table" and can be accessed by the other methods of this class that operate on the
      currently selected table. If you call use() again for another table, that table becomes the
      currently selected table. You can change the currently selected table later by calling the
      select() method and passing to it the alias name assigned by the original use() method call.
      When finished with the table, call `closetable()` and pass the alias name assigned when the table
      was opened. The method `closedatabases()` will also close the table (and close all other open
      tables too). (Changed the mechanism by which the alias is handled 02/19/2015. JSH.)

      :param tableName: path name to the dbf table you want to open.  Must have the .dbf extension             unless the table you wish to open has some other extension; but .DBF is not             enforced, in other words.  Up to you as to how much info you pass in the             path name, but if the file can't be found the method reports an error.
      :param alias: an optional character string with an alphanumeric string starting with a             letter or underscore which will be used as the alias for subsequent table and field            manipulations.  The presence of this value determines how tables are opened when            multiple tables might be opened with the same base file name but in different            directories.  Two cases:

                    1 - An alias is specified.
                        If a table with that alias is already open (either this same table or another one in                    a different directory but with the same base name), that table is closed, and then                    this table open happens and the alias you specified is assigned.  Otherwise the                    table is simply opened and this alias name is assigned.

                    2 - NO alias is specified.
                        A default alias is determined, which is equal to the base table name (other than                    path and extension) of the table with embedded spaces and punctuation removed, if any.                    If this same table is already open with that alias, it is closed and re-opened with your                    required properties.

                        If a different table is already open with that alias, it is left open, and a new                    unique alias is created as 'TMP' followed by a string of 12 random characters.  The                    table specified in this function call is then opened with that new alias.

                    If you do NOT specify an alias, the alias name is NOT guaranteed to be the table                base name.  If you will need to manipulate the tables and you don't specify an alias                name, you MUST store the alias name value provided by the alias() method immediately                after the table is opened, and use that alias name for select() and similar functions                which take an alias name parameter.

                    The same table is allowed to be opened multiple times, each with its own alias.  Remember                in that case that closing one of the instances will NOT close the other(s).
      :param readOnly: boolean value which defaults to False.  If set to True, then the table is            opened in a mode which prevents any record updates or record appends.            Reads from tables opened readOnly are faster, and readOnly is preferred when            writing is not actually required.
      :param exclusive: boolean value which defaults to False.  If set to True, then the table is            opened in exclusive mode.  This means that while the table is open, no other            process may open or access it.  Exclusive mode is required for safely            applying indexes in situations where other processes may attempt access.  When            exclusive is True, the setting for readOnly is ignored and defaults to False.
      :param noBuffering: Boolean value defaults to False.  Set to True to force the CodeBase engine            to read/write directly from/to disk without any in-memory buffering of data.            This may be useful for tables with lots of multi-user access.  However you            may still need to call flush() if data corruption issues are encountered.  If            this flag is set True, some performance penalty may be experienced.

      :returns: True on success, False on any error


   .. method:: maketempindex(self, lcExpr, tagFilter='', descending=0)

      Creates a temporary, single use index that only lives as long        as the table is open.  This index has only one order embedded in it.  Similar to indexon, which        creates permanent indexes.

      This method call applies the        index to the currently selected table and makes the new temp index the current order selection.  You        can traverse the file in the temp index order but seek() is not currently supported.  However, the        locate() method will exploit available temporary indexes if they allow the locate to be optimizable.
      You can change to different orders in the regular index file (CDX) by using setorderto() while you keep        this temp index open.  Open temp indexes are updated when records are changed, added or deleted in the        table.

      The temp index is associated with one alias -- the currently selected one when the index was created.  If        the same table is open with a different alias, it cannot be accessed by that different alias with this        index order.

      Multiple temporary indexes can be opened for a table at the same time, and you can switch back and forth        among them as required.  Closing the table with the closetable() method, closes all temporary indexes        associated with the specified alias and deletes the files they were stored in.

      :param lcExpr: MUST be a valid VFP index expression
      :param tagFilter: if non-blank, must be a valid VFP logicalfilter expression. See indexon() for details.
      :param descending: Allows the index to travers in reverse order if set to 1 to have the index constructed in            reverse order (highest at the top).  The 'unique' option is not available for temp indexes.

      Returns: a valid index code >= 0 or -1 on error. The method returns a temp index code which you should         store in case you need to set the ordering back to        this temp index with `selecttempindex()`, which uses the index code as its parameter.


   .. method:: selecttempindex(self, lnCode)

      Once a temporary index has been created with maketempindex, if you have needed to change the index order
      for any reason, you can restore the temporary ordering of a previously created temp index. Store the return
      value from maketempindex() and use it as the lnCode parm value in this method.  Subsequent goto() and skip()
      method calls will use the temp index.


   .. method:: closetempindex(self, lnCode)

      Temporary indexes are automatically destroyed when the table they relate to is closed.  If you want
      to close the temporary index before the table, pass the index code to this method.  You may wish to do
      this if you are going to be adding a large number of records to the table, and don't want the possibly
      useless overhead of updating the temporary table(s) on every append.  Returns True on OK, False on failure.


   .. method:: updatestructure(self, cSourceTable, cTargetTable)

      This function examines the field structure and index tags of the source table referenced by cSourceTable
      and forces the table named in cTargetTable (not currently open) to have the same structure and index tags.  The
      current content of the target table is retained so long as all of its fields are retained.  Data in fields
      which are not contained in the cSourceTable table will be lost.
      :param cSourceTable: Full path name of the source table, the source of the structure/tags, not currently open.
      :param cTargetTable: DBF table to be modified with the structure and index tags of the pattern (source) table.
      :return: True on success, False on failure or any error.

      NOTE: Do NOT, repeat DO NOT, use this method to modify the structure or indexes of a VFP table contained
      in a VFP database container.  If you do, the table may become un-readable!


   .. method:: indexon(self, lcTag, lcExpr, tagFilter='', descending=0, unique=0)

      Method that creates an index tag for the currently selected open DBF table.  The indexes are stored
      in the associated .CDX file with the same base name as the DBF table.  Each "Tag" represents one
      index ordering which can be used for searching and traversing the table.

      If no DBF is currently selected, or some other problem occurs, it returns False
      otherwise returns True.  This method creates and modifies the VFP type CDX index
      files which may contain multiple physical indexes, each identified by a Tag name.
      It is expected that there will be one and only one CDX index for the table.  In VFP
      and CodeBase, this one-to-one limit is not enforced, but with one CDX file having the
      same base file name as the table, you are assured that the index will be updated with
      its key values whenever the underlying table field values change.

      If no CDX file exists for the table, one is created and the requested tag added to it.

      If the tag exists, it is replaced with your new tag without any warning.

      :param lcTag: a character string of up to 10 alphanumeric values starting with a letter.  This is the name            of the index tag.  You use this tag name to specify an ordering of the table with the setorderto()            method.
      :param lcExpr: a character string containing an index expression with one or more fields            defining the index 'key'.  VFP and CodeBase are very flexible relative to index expressions.  You can            mix various types of fields, define their order and use internal functions to transform them:
      :param Example:
      :param ::: cTagExpr = "UPPER(LAST_NAME) + DTOC(BIRTHDATE, 1) + STR(SALARY)"
                 oDB.indexon("COMPLEXTAG", cTagExpression)
      :param tagFilter: optional character string with an expression limiting the index to records which match            this expression.  If a tag filter is set on an index, traversing the table by the index will only show            the records which are allowed to be visible by the filter expression.
      :param descending: indicates the "direction" of the sort order being indexed.  0 indicates the default            ascending order, otherwise pass a non-zero integer for desencding order (starting with the largest            value and "descending" to the smallest.)
      :param unique: one of several values determining how duplicate key values will be handled when the table            is indexed or new records are added:

                     - 0 = No special handling, duplicate key values are recorded in the index normally.

                     - 15 = VFP Compatible "Candidate" index.  Duplicate key values will result in an error condition if                  encountered in the table.  Both VFP and CodeBase recognize this index type.

                     - 20 = CodeBase compatible setting.  Duplicate key values will result in an error condition if                  encountered in the table by CodeBase BUT, when VFP accesses or indexes the table it will behave                  like code 25.

                     - 25 = VFP type UNIQUE index.  In this case when the table is indexed, only the first occurrence of a                  duplicate is stored in the index.  If the table is traversed or browsed in this index order,                  it is possible that not all records will be visible or be displayed.  Behavior is the same                  for VFP and CodeBase.

      :returns: True on success, False on any error (see properties cErrorMessage and nErrorNumber for            more information)

      NOTE: As of Oct. 26, 2013, see method setstrictaliasmode(), which may be required to support this method              if you are using c4DLL.DLL versions earlier than the one provided as Open Source on GitHub.

      IMPORTANT NOTE!!! Do NOT attempt to use this method to add an index to a table contained in a VFP Data Dictionary        Container.  Such tables can ONLY have indexes changed using VFP itself.  However, those indexes CAN be        reindexed successfully by the reindex() method.


   .. method:: getErrorMessage(self)


   .. method:: select(self, lcAlias)

      Method that sets the currently selected table to the one with the alias passed as the
      parameter. If the string value you pass is not associated with an open table, a False is
      returned. If the string is associated with an open table, that table becomes the currently
      selected table, and a True is returned. Note that alias names are NOT case sensitive in VFP
      or in this module.


   .. method:: dbf(self, alias='')

      Returns the fully qualified path name of the currently selected table or the table
      referenced by the optional parameter alias.  Returns the empty string if there is no
      currently open table or if the alias doesn't exist.


   .. method:: isreadonly(self, alias='')

      Returns True if the specified open data table was opened in read only mode, otherwise false.
      :param alias: Specify the target table alias or leave empty for the currently selected table.
      :return: True if opened readonly.  If in read-write or exclusive mode, returns False.  Returns None
      on error - typically table not opened.


   .. method:: used(self, alias)

      Pass a text string with an alias name.  If that table is open, the function will return True,
      otherwise false.


   .. method:: alias(self)

      Method that returns the alias name of the currently selected table. If there is no
      currently selected table, returns an empty string "". Call this immediately after a table
      use() or createtable() if you need to capture the alias, especially if you may have opened
      or created a table with a temporary or externally defined name, and don't want to make
      assumptions about what default name might have been assigned to the table and have not set
      the alias name yourself.


   .. method:: goto(self, gomode, gonum=1)

      Primary method for navigating through the currently selected table. Functionality is
      similar to the GOTO command in Visual FoxPro and xBase languages. Unlike SQL-based
      databases, VFP tables can be accessed navigationally by moving around amongst the records in
      the table using variations of this method. Returns True when navigation is successful,
      otherwise False. If False, inspect the cErrorMessage and nErrorNumber properties for more
      information. The effect of this method is to move the current record pointer. The current
      record will be the source of field information when the scatter() method is executed and the
      target of updates when the gathermemvar() method is executed. If an order based on an index
      Tag has been set by setorderto(), all gomode values except RECORD honor the index order.

      :param gomode: character string containing one of the following values:

                     - RECORD - In this case you must supply the second parameter gonum with an integer                  value specifying the record number to move to. If the record number
                       specified doesn't exist, the method returns False

                     - SKIP - Moves the current record point forward or back a specified number of records                  (in index order if one has been set). If gonum is not supplied, then moves                  forward by one record.  If gonum > 1, moves forward by gonum records if                  possible. If EOF() is reached before gonum records, returns False.  If gonum                  < 0, moves backwards by gonum records if possible. If BOF() is reached                  before gonum records, returns False.

                     - NEXT - Identical to SKIP with gonum = 1.

                     - PREV - Identical to SKIP with gonum = -1.

                     - TOP  - Moves to the top record by the current ordering (or record 1 if there is no                  index Tag ordering in effect).  If there are no records in the table, returns                  False.

                     - BOTTOM - Move to the the last record by the current ordering (or the highest record                  number if there is no index Tag ordering in effect).  If there are no records
                       in the table, returns False.
      :param gonum: used for gomode values of 'RECORD' for the record number and 'SKIP' to indicate the number            of records to move forward or backward in the table.

      :returns: True on Success, False on Failure for any reason. Inspect the cErrorMessage or nErrorNumber
                for reasons.


   .. method:: calcfor(self, stat='SUM', fldexpr='', forexpr='')

      Calculates a statistic from a numeric expression in fldexpr based on the records in the currently selected table
      that satisfy the logical expression contained in forexpr.  Returns a float value result of the calculation.
      Returns None on any kind of error (for example an invalid expression string).  See locate() for examples of
      valid contents for the forexpr parameter.  This obeys the setting of DELETED.

      Other considerations:

      - Must NEVER be used in the midst of a locate/continue/locateclear sequence. If it is,
        it will return None error.
      - Does not alter the current record pointer position, so can be called on the current table in the middle
        of a scan().
      - Since this executes entirely in the 'C' engine, it will be much faster than scanning through a table
        with Python code calling lower level CBTools functions.
      - If the fldexpr contains only the name of an Integer type field, the result will always be 0.0 UNLESS
        you append a "+0" to the expression (due to an oddity in the way CodeBase handles Integer fields).  So,
        if S_NUM is an Integer, and you need the sum of these values, pass "S_NUM+0" as the value of fldexpr.  This
        does not apply to Number type fields.  It has not been tested with Double, Float, or Currency type fields.

      :param stat: Specifies the type of calculation to be performed on the table.  Allowed values are:

                   - "SUM" - totals the values in the fldexpr
                   - "AVG" - produces a simple average
                   - "MAX" - what it says
                   - "MIN" - what it says.
      :param fldexpr: An expression including at least one field name of an appropriate type (I, N, F, etc.) which will            be evaluated for each record which matches the forexpr if provided.
      :param forexpr: A logical expression involving at least one field in the target table.  An empty string will            result in the calculation being performed for ALL records.

      :returns: The results of the calculation as a float.  0.0 may be a valid returned value.  Check the value of self.nErrorNumber
                if you receive 0.0 and expected something else.  Invalid expressions will result in a return value of None.


   .. method:: deleted(self)

      Determines if the current record of the currently selected table has been marked for deletion.
      Returns True if the record has been marked for deletion.  Returns False if it hasn't.  Returns
      None if there has been an error.

      Inspect cErrorMessage and nErrorNumber if None is returned for more information.


   .. method:: recno(self)

      Returns the record number of the current record of the currently
      selected table. Returns the record number on success, -1 on any kind of
      failure.

      When a table is opened the record pointer is automatically moved to
      record 1, if it exists, and there is no selected index tag. If you need
      to work on a record, then move to some other records, and later go back
      to the original record, it is much faster to save the recno() value and
      return to that record using the goto("RECORD", nTheRecord) method.

      It is possible for the recno() value returned to be one greater than
      the number of records as returned by the reccount() method. In that
      case, the record pointer is at an EndOfFile condition, and eof() will
      return true.


   .. method:: countfor(self, expr)

      Counts the number of records in the currently selected table that satisfy the logical expression contained
      in expr.  Returns a value from 0 to the number of records in the table on success.  Returns -1 on any kind
      of error (for example an invalid expression string).  See locate() for examples of valid contents for the
      expr parameter.  This obeys the setting of DELETED.
      Other considerations:

      - Must NEVER be used in the midst of a locate/continue/locateclear sequence. If it is,
        it will return -1 error.
      - Does not alter the current record pointer position, so can be called on the current table in the middle
        of a scan().


   .. method:: locate(self, expr)

      Attempts to find the first record in the table for which the logical expression in the expr parm
      evaluates to True.  See also locationcontinue() and locateclear() for how to continue the process as you
      work your way through the table.

      Comparable to the VFP LOCATE command.  This operates ONLY on the currently selected table.

      Args:
      expr: A string value containing a logisal expression referencing one or more fields in the table.        This must contain a valid VFP/DBASE type expression and may include .AND., .OR., and other logical         expression elements.  Field names in the currently selected table may be included as well as VFP/DBASE        functions supported by CodeBase.  If any of the logical expressions contained in expr match index        expressions in index tags on the current table, CodeBase will optimize the search to take advantage         of the index.

      Returns:
      Returns True on success (found a record), False on failure for any reason.  Inspect nErrorNumber if there        is a possibility of an error condition.  It will have the value 0, if it is a simple no-find situation.        The most likely error conditions arise from invalid expressions.  The examples below are both valid.

      Example:
      ::
          'UPPER(LAST_NAME) = "JONES" .AND. UPPER(FIRST_NAME) = "PETER" .AND. SSN = "123456789"'
          'STR(RecordKey) + TTOC(dateField, 1) + COMPANY = "   123456720120629053329UNITED COPPER"'

      In the first example if there is an index on the expression UPPER(LAST_NAME) the search will be partially        optimizable and will be substantially faster than a brute force search through the table.  In the second        example, for it to be optimizable, an index tag would need to exist with the expression exactly the        same as the expression to the left of the = sign.

      Note that logical expression operators like .AND. and .OR. are required to have the periods.  VFP is        tolerant of having those operators given simply as AND or OR, but the CodeBase DLL is not.  The allowed value        for True is .T. or .TRUE., for False it is .F. or .FALSE., where the period are required.

      For testing the value of DATE or DATETIME type fields directly, you need a text string that contains        the appropriate CodeBase function with the required parameters to test the match. See the two        CodeBaseTools functions below to obtain the appropriate text strings for this match:

      - dtt2expression()
      - dtd2expression()

      For example if a table has a field BIRTHDATE, and you want to locate records that have a
      birthdate of July 7, 1986 you'd use this code where oCBT is an instance of cbTools():

      Example:
      ::
          cDateMatch = oCBT.dtd2expression(datetime.date(1986, 7, 7))
          cExpr = "BIRTHDATE = %s" % cDateMatch
          oCBT.locate(cExpr)

      Special considerations for searching for text strings: First note that the equality sign exists only        in one form: =, not in two as in VFP (= and ==), and that unlike in Python, it is a single equal sign.        When applied to a comparison with a string, the comparison is limited to the number of characters in        the match expression to the right of the equal sign.  So if the LASTNAME field contains "JOHNSON",        the following expressions will all be true:

      Example:
      ::
          LASTNAME = "JOHN"
          LASTNAME = "JOHNSON"

      but the following will be false:

      Example:
      ::
          LASTNAME = "JOHNSEN"
          LASTNAME = "Johnson"

      In addition, there is a $ operator which signifies "is contained in".  So with the above value of the
      LASTNAME field the following expressions would also be True:

      Example:
      ::
          "JOHN" $ LASTNAME
          "OHNSO" $ LASTNAME

      Finally, relative to character matches, remember that in xBase DBF tables, character fields are
      ALWAYS padded to their full width with spaces.  So in a LASTNAME field with a defined size of 20
      characters and a value of "JOHNSONNEN":

      Example:
      ::
          LASTNAME = "JOHNSON" # Evaluates to True
          LASTNAME = "JOHNSON " # Evaluates to False, allowing you to establish an exact match.
          LASTNAME = "JOHNSONNEN " # Evaluates to True, again testing for the exact match.

      See also the locateclear() and locatecontinue() methods which may be used on conjunction with locate()

      While you are debugging, or where the expr value may be created by a user, the error number should always
      be checked when False is returned, as False may be the result of an illegal expression.

      WARNING!  The locate(), locatecontinue(), locateclear() sequence may NOT be nested.  Only ONE locate
      process may be in effect at any one time!!!

      NOTE: calling locate() clears the previously called locate(), so locate() may be called repeatedly if just one
      record is needed each time.  At the end of calling a bunch of locates, you should then clear the locate sub-
      system with a locateclear() since some other lookup functions may use the locate() logic internally, and will
      fail if there is a pending un-cleared locate active.  To be safe, call locateclear() after any locate() if
      you won't be needing its results or locatecontinue() any more.

      ALSO NOTE: Locate will not work consistently with the current index set to a descending index.  Use some        form of scan with an expression instead, which can traverse an index in reverse.

      See also locatecontinue() and locateclear()


   .. method:: locatecontinue(self)

      After a successful call to locate(), you can call this method repeatedly until it returns False, to find
      additional records matching the original logical test expression.

      :returns: True on Success. On False, nErrorNumber will be non-zero if an error has occurred.  nErrorNumber will be 0 if there            simply are no more matching records.

      locatecontinue() will traverse the table in the currently set order or in record number order if there
      is no set order.  locatecontinue() called without a corresponding initial locate() will produce
      either an error condition or an undefined result.

      When locatecontinue() is called the currently selected table MUST be the same as was selected at the time
      the preceding locate() was called or the results will be undefined.

      It is STRONGLY recommended that after the last locatecontinue() method call in the series, the
      locateclear() method be called to release memory and allow normal processing, seek(), etc., of the
      currently selected table.

      See also locate(), locateclear()


   .. method:: locateclear(self)

      This method clears memory allocated for the locate() method and prepares the system for other searches.

      It is REQUIRED after any locatecontinue() calls.

      Returns True on success, False on failure, but the return value may normally be discarded.


   .. method:: deletetag(self, tagname='')

      Specify a tag name in the CDX index of the currently selected table to be removed from the CDX file.  If the
      last tag is removed from a CDX index file, the CDX index file is deleted and the DBF file is marked as having
      no index files.  DO NOT use this method to remove an index tag from a VFP table contained in a VFP Database
      Container.  Doing so will result in data corruption.  This can only be applied to so-called VFP Free Tables.


   .. method:: setorderto(self, tagname)

      If the currently selected table has one or more index tags available, this method will set
      the current ordering (which is recognized by the various modes of the goto() method) to the
      tag specified by tagname. Returns True on success, False on failure for any reason. Inspect
      the cErrorMessage or nErrorNumber for reasons.  Pass "" as tagname to set to native recno order.


   .. method:: ataginfo(self)

      Retrieves index tag information for the currently selected table.  If there are no index tags, returns
      an empty list.  Otherwise returns a list consisting of one VFPINDEXTAG object for each list element.

      The VFPINDEXTAG objects each have five properties defining the characteristics of the index tag:
          - cTagName - The name of the sort order tag name.  Use this string value to set the current order
                       to this index using the setorderto() method.
          - cTagExpr - The expression defining the tag.  At minimum this will be the name of one field or a function
                       like DELETED() that relates to the contents of each record.  It can be a much more complex
                       expression like "UPPER(first_name)+UPPER(last_name)+STR(salary)".
          - cTagFilt - If the index tag is to only have visibility to a subset of records, this filter expression can
                       contain a logical expression containing references to one or more fields.  In that case, if you
                       set order to the tag and execute skip() or copytoarray(), only records for which this expression
                       evaluates to True will be recognized.
          - nDirection - 0 if ordering is standard ascending order.  10 if ordering is descending with largest values
                         at the top.
          - nUnique - value of 0 if duplicate index key values are allowed.  Value of 20 if an attempt to add a record
                      that has a key identical to an existing key value will trigger an error.

      If there is no currently selected table or some other error occurs, returns None.

      Sets the value of the property tally to the number of tags.  0 is a valid value (no index tags defined), and -1
      indicates an error.

      Return a list() object or None on error.


   .. method:: order(self)

      Retrieves the index tag previously set by setorderto() from the currently selected table.  Returns a
      string containing the tag name of the index tag set or an empty string if one isn't set or there is no
      currently active table.  If an error occurred (likely no table selected), the cErrorMessage and
      nErrorNumber properties will be set.


   .. method:: deletetagall(self)

      Deletes all index tags for the currently selected table. The CDX index file is deleted and the
      DBF file is marked as having no index files.  Returns True on success, False on failure.  Returns True
      if there are no tags set up for the table, even though there is nothing to do.  DO NOT use this method to
      remove index tags from a VFP table contained in a VFP Database Container.  Doing so will result in data
      corruption.  This can only be applied to so-called VFP Free Tables.


   .. method:: dtt2expression(self, dateTimeValue)

      Pass a date/time value and this will return a text string appropriate for a constant datetime value
      in an expression for a location or calculate function.  In VFP a constant date/time value is expressed
      with elaborate notation like {^2013-02-15 12:35:00}, but Codebase doesn't recognize this.  Instead,
      it wants a function like "DATETIME(2013, 2, 15, 12, 35, 0)".  This function produces that latter string value.


   .. method:: dtd2expression(self, dateTimeValue)

      Similar to dtt2expression() except it uses the STOD() function to match date type fields. NOTE that the
      Python values returned from VFP DATE and DATETIME fields are always Python datetime objects, BUT in VFP
      they are different entities and can't be compared directly.  So if a field is a type DATE, you must create
      the matching expression with the STOD() function using this method.  Also note that STOD() is NOT a VFP
      function but a dBase function recognized by CodeBase in expressions.


   .. method:: dt2seek(self, dateValue)

      Pass a date value, and this returns the proper string format required for the seek() method below.


   .. method:: dtt2seek(self, dateTimeValue)

      Pass a datetime value, and this returns the proper string format required for the seek() method.


   .. method:: getdatasession(self)

      When multiple instances of this class exist, each will be given its own data session.
      Other instances may set the "current" session to a different value.  If you find your
      table is not reported 'open', when you think it should be try storing the session number
      of your instance and restore to it with setdatasession().  If you change a current data session
      be sure to put it back when exiting the function.
      :return: Integer session number


   .. method:: setdatasession(self, nSession)

      set the data session back to what it was earlier.  the session number MUST be one that came
      from getdatasession() or the results will be undefined.
      :param nSession:
      :return: The session number switched to or -1 on error


   .. method:: curvalstr(self, lcFieldName)

      Retrieves the contents of one field specified by the parm lcFieldName.
      If you want a value from a table other than the currently selected one,
      use the alias.fieldname notation in the name of the string you pass in
      the lcFieldName parameter.

      Designed for speed with minimal checking. Works OK with char, memo,
      number, currency, and date type fields. Does not produce useful results from
      integer, double, datetime, or float type fields.  Note that the contents of char fields
      are padded with blanks to the full size of the fields.

      :returns: Returns a text string representation of the field value. No conversions
                are performed. An empty string is a valid return value, but if you
                expect something else, check the error messages. An empty string is also
                returned if the lcFieldName is not found in the current table or if your
                specified alias doesn't exist.

                - Returns None on error, and sets errormessage and errornumber
                - Returns None when field allows null and has a null value, but does NOT set errors.


   .. method:: curvalstrEX(self, lcFieldName, lbStrip=False)

      Retrieves the contents of one field specified by the parm lcFieldName.
      If you want a value from a table other than the currently selected one,
      use the alias.fieldname notation in the name of the string you pass in
      the lcFieldName parameter.

      Designed for speed with minimal checking. Works OK with char, memo,
      number, currency, and date type fields. Does not produce useful results from
      integer, double, or float type fields.  May truncate the contents of Unicode
      strings contained in char(binary) and memo(binary) fields.

      Enhancements over curvalstr:
          - Allows specification of stripping trailing blanks.

      :returns: Returns a text string representation of the field value. No conversions
                are performed. An empty string is a valid return value, but if you
                expect something else, check the error messages. An empty string is also
                returned if the lcFieldName is not found in the current table or if your
                specified alias doesn't exist.


   .. method:: seek(self, targmatch, alias='', indextag='')

      This method is closely analogous to the VFP SEEK() function and uses an
      index Tag to find a record matching a specified lookup string (the
      targmatch value). If a matching record is found, returns True, otherwise
      False. False can also be returned for a number of other failure causes,
      and the nErrorNumber should be checked for a non-zero value to identify
      error situations. Unlike setorderto(), gathermemvar(), alias() and many
      other methods, this one doesn't have to work on the currently selected
      data table. This allows you to do a seek() into another table in the
      middle of traversing the currently selected table. You can retrieve
      field values from the found record in that other table using curval() or scatter()
      which allows you to specify the table from which to return the field
      value.

      :param targmatch: A text string containing the value to find by the specified index tag.            For example if there is an index Tag with an expression of "UPPER(xCode            + yCode)" where xCode and yCode are each character fields of length            10, and you wanted to find a record with an xCode value of "abc" and a            yCode value = "yior" you would construct the targmatch as "ABC       YIOR      ".            Note that in DBF files character fields are automatically            padded to their full length with space characters, and a concantentation            of field values will include those spaces. Also note that the targmatch            values are all upper case because the field values in the example tag            expression are wrapped in a UPPER() function.

                        Some further rules for Tag expressions:

                            - If the field indexed is a date field, the index expression must be a                    character string of the form "YYYYMMDD".

                            - If the field indexed is any type of number, the index expression must                    be a character string containing a text representation of the value                    being searched for. For example, if the field is an integer and                    you are searching for 29502, the targmatch string should be "29502". For                    number, double, and currency type fields, be sure to include the decimal                    point in your text string.

                            - If the field indexed is a datetime value, the index expression                    required is not exactly what you would expect.                    The required text string should be in the form "YYYYMMDDHH:MM:SS:TTT"                    where YYYY is the year, MM the month, DD the calendar day, HH the time                    hour (24 hour clock time), MM minutes, SS seconds, and TTT thousandths                    of seconds. BUT NOTE: the colons ARE REQUIRED. Also, since DBF tables                    can't store datetime values accurate to the one thousandth of a second,                    the TTT value should always be "000".

                            - The dt2seek() and dtt2seek() methods of this class are provided to translate                    Python date and datetime objects to the required string to get a match in                    a seek() call where the indexed value is either a DATE or DATETIME type field.

                            - If the tag expression is a character string, the targmatch value may                    be equal to or less than the length of the tag expression. If it is less                    than the length of the tag expression it will "find" the first record                    which matches the characters of the tag expression. If the targmatch                    string length is larger than the actual tag expression length, the                    result will always be False.
      :param alias: Allows you to specify the alias name of any currently open            table. If passed as an empty string or omitted the currently selected            table is assumed. Otherwise the table specified by the alias name is the            subject of the seek. The currently selected table is NOT changed.
      :param indextag: Optional specification of the index tag to use for the            seek. If not specified, then seeks using the tag specified in the latest            setorderto() method for the table. In that case, if no current order has            been set for the table, the method returns False.

      :returns: True for success (record is found).  False for any other condition.


   .. method:: skip(self, gonum=1)

      Identical to the goto() method with the "SKIP" gomode value, except it runs a stripped down
      function for speed with only very basic error checking and reporting.

      Returns True if OK, a valid record has been found, otherwise False.


   .. method:: refreshbuffers(self)

      This is a more drastic update of the information on the currently selected table than refreshrecord().
      In this case, the entire cached data for the currently selected table is purged, forcing a re-read from
      the disk of any part of the table required for subsequent processing, including the table header.

      This function incurs substantial disk overhead the next time the table is accessed, so should be used with
      care in loops where performance is a concern.


   .. method:: refreshrecord(self)

      While VFP properly handles the refresh of its internal buffers when another application has changed a table,
      CodeBase does NOT.  If you are working with a table that is potentially subject to changes by an external
      application, and if you have been keeping this table open to save the time of re-opening prior to each
      use, then before accessing the data, you should select the table and then call this method to be sure
      the most recent version of the current record data is in the CodeBase internal buffers.

      Note that this ONLY operates on the data in the current record.  Other records may remain buffered and
      potentially out of date relative to changes made by other processes.

      Returns True on success, False on failure.  On failure records the error message.


   .. method:: flush(self)

      Call this function immediately after a gatherdict() or insertdict() to force the data changes to be written        immediately to the disk.  This will ensure that other users of the data will see it immediately.  Otherwise        CodeBase will buffer writes and could delay these writes until the buffer is full.

      This action applies only to the currently selected data table.

      Returns True on success, False on Error, in which case you need to check cErrorMessage and nErrorNumber.


   .. method:: recall(self)

      The opposite of delete().  This works on the current record of the currently selected table.  If        that record is marked for deletion, then removes the mark.  If not marked for deletion, then does        nothing.

      Returns True on success, False on Error, in which case you need to check cErrorMessage and nErrorNumber.


   .. method:: recallall(self)

      Performs a recall() operation on every record in the currently selected table currently marked for        deletion.  When this is done successfully, there will be no records in the table marked for deletion.

      Returns True on success, False on error, in which case you need to check cErrorMessage and nErrorNumber.

      Sets the value of the tally property to the number of records recalled.


   .. method:: flushall(self)

      Similar to flush() but applies to all open tables.

      Will attempt to lock each record being updated.  Also checks to make sure that there are no duplicate
      values for indexes that require unique keys.  If these tests fail, the flushall() can fail.

      Returns True on success, False on Error, in which case you need to check cErrorMessage and nErrorNumber.


   .. method:: fcount(self)

      Returns the number of fields in the currently selected table or -1 on any kind of error.


   .. method:: reccount(self)

      Returns the physical number of records contained in the currently
      selected table. This will include records that have been marked for
      deletion. Use countrecords() to get the number of undeleted records.

      Returns -1 on error, in which case see cErrorMessage and nErrorNumber.


   .. method:: tagcount(self)

      Returns the number of index tags stored in the CDX index file for the
      currently selected table. Returns 0 if there aren't any.

      Returns -1 on error, in which case see cErrorMessage and nErrorNumber.


   .. method:: eof(self)

      Interrogates the record pointer status of the currently selected table.
      Returns True if the record pointer is at the EOF position or on error. Otherwise
      returns False. If False, the record pointer is not at the end. Otherwise EOF or
      an error has occurred and you should take further action.


   .. method:: fieldinfo(self, fieldname='')

      Gets the field structure info for just one field without the bother of afields()
      :param fieldname: may include the alias
      :return: tuple - (type, length, decimals, allow nulls, is binary) or None on error.


   .. method:: afields(self, lpcAlias='')

      Retrieves field structure information for the currently selected table or the specified table designated
      by alias name.

      Returns a list of VFPFIELD objects, each containing information on one field, the list is in order as the
      fields physically appear in the table.  See the doc for createtable() for how the output of this method
      can be used to create a duplicate of the table.

      The properties of the VFPFIELD object are detailed in the createtable() documentation.

      If there is no currently selected table, or the alias isn't recognized, or some other error occurs, returns None.


   .. method:: afielddict(self, lpcAlias='')

      Similar to afields in that it retrieves field data, but it returns a dict() keyed by the field name (always
      upper case), containing the object pointer for the field info structure.  Makes it easy to get specs
      on individual fields without looping through the list returned by afields()
      :param lpcAlias:
      :return: see above. Returns None on error

      See also fieldinfo() method for just one field's characteristics.


   .. method:: getfieldinfo(self, lpcFieldName='')

      Returns info on the width, decimals, type, nulls for a field in the currently selected table.

      Return value is None, if the field doesn't exist in the current table or there is no currently selected table.

      Returns tuple of (cType, nLength, nDecimals, bNulls) if field is found.

      This is retained for backward compatility.  Use fieldinfo() method instead which calls the
      'C' engine directly for this information.


   .. method:: afieldtypes(self)

      Utility function which returns a dictionary containing field type information for the currently selected table.

      The keys to the dictionary are the field names.  This provides an easy way to tailor any data preparation for
      storage in a specific field, based on the target field type.

      Returns the dictionary on success, None on failure.  Much faster than getting all afields() info, but NOTE:
      the ordering of the dict() is unrelated to the sequence of fields in the table.


   .. method:: scatterblank(self, lcAlias='', lbBinaryAsUnicode=True)

      Returns a dictionary for an empty record in the currently selected table or the table specified by
      alias.  Contains one item keyed by the uppercase of the field name and having a value representing an
      empty field.  For example, if the field is an INTEGER, the value will be 0.  If the field is a LOGICAL,
      the value will be .F. (VFP False).  If the field is CHARACTER, the value will be an empty string.  For
      DATE and DATETIME fields, the value will be Python None.

      Added 03/20/2012. JSH.


   .. method:: scatter(self, alias='', converttypes=True, stripblanks=False, fieldList=None, coding='XX')

      The most generally used way to retrieve the contents of a data record
      from the current record of the currently selected table or a table whose
      alias you specify. Returns information on the contents of all fields in
      the table.

      :param - alias = specify the alias of a currently open table if you want a: table other than the currently selected table. Does not change the
                                                                                  currently selected table unless there is no currently selected table.
      :param - converttypes = Pass a value of False to get all values as text: representations of their field values. For example, with convertypes
                                                                               True, date values are returned as Python dates. With convertypes False,
                                                                               date values are returned as strings of the form "YYYYMMDD".
                                                                               There is a small, but potentially significant improvement in performance
                                                                               for data retrieval when converttypes is False, but that may be offset by
                                                                               the requirement for further data conversion in your Python application.
      :param - stripblanks = If set to True: to strip off all the trailing blanks on all character fields. Note that
                                             in VFP and all DBF tables, character fields are padded with blanks to
                                             the full width of the field.
      :type - stripblanks = If set to True: default is False
      :param - fieldList = if not None: to be included in the dictionary, separated by commas.
      :param it should be a string of upper case field names: to be included in the dictionary, separated by commas.
      :param - coding = XX: Recommended that you leave as default in Python 2.x.
      :type - coding = XX: default

      :returns: On success returns a dictionary consisting of field name keys and field
                values. On failure returns the value of None and the cErrorMessage and
                nErrorNumber values will be set for more information. You can modify the
                values for individual fields in this dictionary and then store the
                changes back to the table by passing the dictionary as the dData
                parameter to the gatherdict() method.


   .. method:: scattertolist(self, alias='', converttypes=True, stripblanks=False, fieldList=None, coding='XX')

      Like scatter except that instead of returning a dict(), it returns a list of tuples which
      can be sent via a COM connection to a COM client with the full record.

      :param - alias = specify the alias of a currently open table if you want a: table other than the currently selected table. Does not change the
                                                                                  currently selected table unless there is no currently selected table.
      :param - converttypes = Pass a value of False to get all values as text: representations of their field values. For example, with convertypes
                                                                               True, date values are returned as Python dates. With convertypes False,
                                                                               date values are returned as strings of the form "YYYYMMDD".
      :param - stripblanks = If set to True: to strip off all the trailing blanks on all character fields. Note that
                                             in VFP and all DBF tables, character fields are padded with blanks to
                                             the full width of the field.
      :type - stripblanks = If set to True: default is False
      :param - fieldList = if not None: to be included in the dictionary, separated by commas.
      :param it should be a string of upper case field names: to be included in the dictionary, separated by commas.
      :param - coding = default string text coding or values per class docstring.:

      :returns: On success returns a list consisting of field names and field
                values as a tuple for each field. On failure returns the value of None and the cErrorMessage and
                nErrorNumber values will be set for more information.


   .. method:: scattertorecord(self, alias='', converttypes=True, stripblanks=False, fieldList=None, coding='XX')

      Works just like scatter() except that it returns a named tuple with each element having a name
      equal to the uppercased field name, thus: myResult.MYFIELD01
      :return: The named tuple can either be accessed by index number or by the name of the item in the tuple.

      Slower than plain scatter(), but may result in more readable code when handling the resulting output.


   .. method:: scattertoarray(self, alias='', converttypes=True, stripblanks=False, fieldList=None, coding='XX')

      Retrieves the contents of a data record from the current record of the        currently selected table or a table whose alias you specify. Returns        information on the contents of all fields in the table.

      :param - alias = specify the alias of a currently open table if you want a: table other than the currently selected table. Does not change the
                                                                                  currently selected table unless there is no currently selected table.
      :param - converttypes = Pass a value of False to get all values as text: representations of their field values. For example, with convertypes
                                                                               True, date values are returned as Python dates. With convertypes False,
                                                                               date values are returned as strings of the form "YYYYMMDD".
      :param - stripblanks = If set to True: to strip off all the trailing blanks on all character fields. Note that
                                             in VFP and all DBF tables, character fields are padded with blanks to
                                             the full width of the field.
      :type - stripblanks = If set to True: default is False
      :param - fieldList = Comma delimited list of field names to include in the output.:
      :param - coding = XX for system text conversion defaults or a codec or Unicode value from: docstring of this class.

      :returns: On success returns a simple list of field values in the order in which the fields are found
                in the table OR in the order in which the fields were listed in the fieldList parameter.  Returns
                None on error.


   .. method:: curval(self, lcFieldName, convertType=False, coding='XX')

      This is a generic CURVAL() (see VFP Function CURVAL()) that returns the
      value of a specified field found either in the currently selected table
      (just pass the field name) or in any open table (prefix the field name
      with the table alias and a '.' in the lcFieldName parameter. If
      convertType is False or omitted, returns a tuple consisting of the
      string representation of the field value followed by the type of the
      value. See scattertoarray() for more details on the formatting of date
      and datetime values and type codes. If convertType is True, then returns
      a single scalar value of the Python type corresponding to the field
      value type.  Char and Memo fields will always return type string with
      coding as set by the coding parm.  If convertType is False all other field types
      will be in plain ASCII stored in string variables, except for binary char and
      memo fields, which will be returned as bytearray (ver 2.x) or bytes (ver 3.x).

      Returns (None, None) or None on error. May also return None on fields
      containing empty dates. If you are expecting a date field and receive
      (None, None) or None, check the cErrorNumber for a non-0 value
      indicating an error.


   .. method:: curvallogical(self, lcFieldName)

      Retrieves the contents of one field specified by the parm lcFieldName.
      This field MUST be of type LOGICAL. If you want a value from a table
      other than the currently selected one, use the alias.fieldname notation
      in the name of the string you pass in the lcFieldName parameter.

      Returns a Python value of true or false. A value of None is returned on
      error. If you have any doubt about the None value returned, then check
      the error messages. A non-blank error message may indicate an invalid
      field name or a non-existant alias name.

      Designed for speed with minimal checking. Works ONLY with logical type
      fields. Does NOT produce useful results from ANYTHING else.


   .. method:: curvaldatetime(self, lcFieldName)

      Retrieves the contents of one field specified by the parm lcFieldName.
      This field MUST be of type DATETIME or of type DATE.

      If you want a value from a table other than the currently selected one,
      use the alias.fieldname notation in the name of the string you pass in
      the lcFieldName parameter.

      Returns a Python datetime.datetime() value. A value of None is returned if the
      field value is empty or on error. If you have any doubt about the None
      value returned, then check the error messages. A non-blank error
      message or an error number other than 0 may indicate an invalid field
      name or a non-existant alias name. If the field is of type DATE, the
      return will still be a python datetime type but the values for hour,
      minute, and second will all be 0.

      Designed for speed with minimal checking. Works ONLY DATETIME and DATE
      type fields. Does NOT produce useful results from ANYTHING else.


   .. method:: curvaldate(self, lcFieldName)

      Retrieves the contents of one field specified by the parm lcFieldName.
      This field MUST be of type DATETIME or of type DATE.

      If you want a value from a table other than the currently selected one,
      use the alias.fieldname notation in the name of the string you pass in
      the lcFieldName parameter.

      Returns a Python datetime.date() value. A value of None is returned if the
      field value is empty or on error. If you have any doubt about the None
      value returned, then check the error messages. A non-blank error
      message or an error number other than 0 may indicate an invalid field
      name or a non-existant alias name.

      Designed for speed with minimal checking. Works ONLY for DATETIME and DATE
      type fields. Does NOT produce useful results from ANYTHING else.  For DATETIME
      fields still only returns the date portion of the value.


   .. method:: curvalfloat(self, lcFieldName)

      Retrieves the contents of one field specified by the parm lcFieldName as a Python float type variable.
      If you want a value from a table other than the currently selected one,
      use the alias.fieldname notation in the name of the string you pass
      in the lcFieldName parameter. This method ONLY works with fields that
      are of type NUMBER, FLOAT, DOUBLE or CURRENCY.  (It MAY work with INTEGER, but
      will return a float, so may not be terribly useful.)

      Returns the number as a float or None on error. Error can be triggered by a bad
      field name, a non-numeric field, or no table open, etc.

      Designed for speed with minimal checking.

      NOTE:!!!!!  In DBF tables, decimal places are defined for NUMBER fields, and their values are
      explicit... in a field of type N(10,2) the value 3.33 is stored exactly as 3.33, not
      as some rounding of a binary representation of that value.  The same is true of CURRENCY fields.
      This method, however, returns the value as a Python float, which IS a binary representation which may NOT
      be exactly the value desired.  For CURRENCY field types, especially, this is generally NOT what is desired.
      To preserve the decimals exactly, use curvalstr() and convert the result into the required
      python type that preserves the decimal exactness you require OR use curvaldecimal().


   .. method:: curvaldecimal(self, lcFieldName)

      Retrieves the contents of one field specified by the parm lcFieldName as a Python decimal.Decimal()
      type value, which contains an exact representation of any fractional portion.
      If you want a value from a table other than the currently selected one,
      use the alias.fieldname notation in the name of the string you pass
      in the lcFieldName parameter. This method ONLY works with fields that
      are of type NUMBER, FLOAT, or CURRENCY.  Note that in Visual FoxPro, a FLOAT type is exactly
      the same as NUMBER.  Conversely, a DOUBLE is stored in binary form, and may not be able to
      represent fractional data precisely.  An attempt to retrieve a DOUBLE field with this function
      will return an ERROR condition (None).

      Returns the number as a decimal.Decimal() object or None on error. Error can be triggered by a bad
      field name, a non-numeric field, or no table open, etc.

      Designed for speed with minimal checking.

      NOTE:!!!!!  In DBF tables, decimal places are defined, and their values are
      explicit... in a field of type N(10,2) the value 3.33 is stored exactly as 3.33, not
      as some rounding of a binary representation of that value.  This method, however,
      preserves the decimal exactness you may require.


   .. method:: curvallong(self, lcFieldName)

      Retrieves the contents of one field specified by the parm lcFieldName.
      If you want a value from a table other than the currently selected one,
      use the alias.fieldname notation in the name of the string you pass
      in the lcFieldName parameter. This method ONLY works with fields that
      are of type INTEGER, DATE, or NUMBER. In the case of DATE, you'll get
      the Julian day number back. In the case of NUMBER, you'll get the whole
      number part of the value back as a long.

      Returns the number or None on error. Error can be triggered by a bad
      field name or no table open, etc.

      Designed for speed with minimal checking.


   .. method:: scatterraw(self, alias='', converttypes=True, stripblanks=False, lcDelimiter='<~!~>', coding='XX')

      IMPORTANT: This function is here for backwards compatibility with older versions of this
      module.  It is deprecated for future new development.  Use scatter() or other retrieval
      mechanisms instead that are now just as fast or faster.

      Retrieves the contents of a data record from the current record of the
      currently selected table or a table whose alias you specify. Returns
      information on the contents of all fields in the table. Applies NO
      formatting or translation of the result data. Use for speed when you are
      confident you know what is in the table and what order the fields are
      found in.

      :param - alias = specify the alias of a currently open table if you want a: table other than the currently selected table. Does not change the
                                                                                  currently selected table unless there is no currently selected table.
      :param - delimiter = string of one or more characters: used as the delimiter between the values in the output string.
      :type - delimiter = string of one or more characters: up to 32

      :returns: On success returns a simple character string containing a simple text
                representation of the value of each table field in order. Returns no
                information about field names. Values are delimited in the string by the
                delimiter string, which defaults to "<~!~>", but can be overridden...
                Returns None on error.


   .. method:: gatherfromarray(self, lxValues, lxFields=None, lcDelimiter='<~!~>', lbIgnoreMissing=True, coding='X')

      **THIS METHOD IS DEPRECATED.  IT HAS ISSUES IN PYTHON 3.x AND HAS BEEN REPLACED BY OTHER METHODS.**

      NOT Recommended with Python 3x!  Note field types not supported!  Limited to text coded in Extended ASCII
      using CodePage 1252. DEPRECATED.

      Use `insertdict()` or `gatherdict()` INSTEAD.

      This function is retained for backwards compatibility and for its modest speed advantage when used within
      its limitations.

      Writes values into the current record of the currently selected table.  If the current record is null or the
      record pointer is at EOF, returns False.  Also returns False if there is no currently selected table.

      VFP's most powerful way to put values into a table record in the "GATHER FROM" command.  This method emulates
      some of its power to be able update a selection of multiple fields all at once without the complication of SQL
      syntax.  The function operates in two modes: Field Specific Mode and All Fields Mode.

      Field Specific Mode:

      In this case you must specify which fields are being updated (by name) and provide a value for each.  This may
      be done in one of three ways:

      Dictionary Mode:

      Supply the first parameter as a dictionary containing the field values keyed by the field names.
      The field values may be any Python type compatible with the type of the associated field.

      For example, either a 1, True, or "T" are all accepted for the value of a LOGICAL field.  Any other type will
      raise an exception of BadFieldValueType.  As another example, for DATETIME or DATE fields you may provide
      either a datetime.date type value or a datetime.datetime value.  But be aware that integers and numbers will
      be accepted for DATE values. In this case, the number will be truncated to an integer and interpreted as the
      Julian Day value (in VFP the number of days since APPROXIMATELY Jan 1, 4800 BCE).  Specifically, the date
      (Current Era or A.D.) February 1, 2011, has a VFP Julian Day value of 2455594.  DATE and DATETIME values can
      also be supplied by tuples of integer Year, Month, and Day values (for DATE) or integer Year, Month, Day, Hour,
      Minute, Second values (for DATETIME).

      For character fields, any value type will be accepted and converted to a character representation.  See
      comments under the Strings input type for more on type conversions.

      Strings are allowed for all field types, but for correct evaluation they must follow the rules specified in the
      Strings section below.

      Lists: This requires a list of field names as the second parameter and a list of field values as the first
      parameter.  The index of the field names and values must correspond.  As with the dictionary input, the field
      value types must be compatible with the type of the target field.

      Strings: Supply the second parameter as a string consisting of an ordered list of field names delimited by a
      non-alpha string.  By default the delimiter is assumed to be <~!~>, but you may specify another string value
      in the lcDelimiter parameter.  The first parameter must be another string containing a concantenated and
      delimited string representation of all values referenced in the field list.  This value string must be ordered
      identically to the field name string.  No type conversions or checking is done in this mode.  For this reason,
      processing is fast, but you are responsible for expressing each field value in the correct format.
      Formats are as follows for each type of DBF field:

          - CHARACTER - Any string value.  Strings longer than the length of the field will be truncated, shorter              strings will be right padded with blanks.  Extended ASCII wirh CodePage 1252 ONLY unless              data passed as a dict().

          - NUMBER - String representation of a floating point value in decimal format, e.g. "394039.395".              For negative values, prepend the minus sign, e.g. "-25904.99".  The actual number of decimals stored is              determined by the field format.  Excess digits to the right of the decimal point will be rounded              off.  Excess digits to the left of the decimal point will trigger a NumericOverflow error.              Number type fields store the exact value, e.g. 2.1 is stored as 2.1 if at least one decimal of              precision is specified, not 2.09999999999999999.  Relative to field size, the size of NUMBER              fields is defined by a total field width and the number of decimal places.  The total field width              must be sufficient to handle the largest value intended for the field INCLUDING the decimal point              AND any prepended minus sign.  For example a field defined as N(7, 3) can accommodate a value of              999.349 or -99.349 but NOT -999.349, as the latter value requires a field of size N(8, 3).

          - FLOAT - Similar to NUMBER, but the precision of the input number will be preserved in the value stored.              However, float values, like all IEEE float and double numeric values are stored as approximations              of the fractional component, e.g. 2.1 double may be stored as 2.0999999999999999.

          - NTEGER - String representation of any 4-byte integer value, e.g. "195023985" or "-234095".  Values with              embedded decimals will be stored with decimal fraction truncated.

          - DATE - String representation of a date as 8 digits in the format YYYYMMDD.

          - DATETIME - String representation of a datetime value (thousandths of a second are not supported).  The              string must consist of 14 digits in the format YYYYMMDDHHMMSS.

          - LOGICAL - The single character "T" for True and "F" for False.

          - MEMO - Any string value.  The maximum length of the string is 2 Gigabytes, but in practice it is much less              since the maximum size of the FPT file which contains all the memo values is itself 2 Gigabytes.  Non              ASCII values may be stored in Visual FoxPro memo fields, but some other versions of DBF tables don't              support this.

          - DOUBLE - Like Number.

          - CURRENCY - Like Number in that it stores an exact representation of the value but with a fixed 4 decimal              places.

          - GENERAL - Not supported except when data are supplied in a dictionary.

          - CHAR BINARY - Not supported except when data are supplied in a dictionary.

          - MEMO BINARY - Not supported except when data are supplied in a dictionary.

          NOTE: Empty DATE and DATETIME values ---
          Visual FoxPro and the DBF format allow the concept of an empty date and empty datetime value.  This is
          NOT the same as a NULL value in these fields.  A NULL is an undetermined value.  An empty date is a value
          of type date that doesn't contain an actual date.  Ditto for datetime.  In VFP an expression like
          somedate={ / / } (that's VFP date notation) is completely legal.  Date and datetime fields in blank
          records start out with the value of empty date and empty datetime respectively.  You can think of the empty
          date and datetime values as analogs of "" and 0 in the string and number worlds.

          Since Python doesn't support empty date or datetime values, this module handles this using the value None.
          To supply an empty date or datetime value in this method, supply the value of None.  If you are supplying
          a string representation of a date or datetime, supply a string of 8 blanks for the empty date value or
          "        000000" (8 blanks followed by 6 zeros) as the empty datetime value.  In methods like scatter()
          and copytoarray() empty date and datetime values are converted to the Python value None.  This will be
          indistinguishable from the value None which can be returned when the contents of the field is NULL.

      All Fields Mode:

      If you are confident that you know how many fields are found in the table and want to quickly update all of them
      at once very simply, you pass as the first parameter an ordered set of values corresponding to all the
      fields in the table.  This single parameter may either be a list[] containing a value for every field in order
      or a delimited string of field values as described above for the Strings type under the Field Specific Mode.  If
      the number of fields you supply is not exactly equal to the number of fields, a MismatchedFields exception is
      raised.  The list form allows non-string values to be passed as above.  Value type checking will be performed
      on non-string types.  The string form does not do value or format checking and passes the delimited string
      directly to the CodeBase engine for storage.

      The lbIgnoreMissing parameter applies if the source (lxValues) is a dictionary.  In that case, set
      lbIgnoreMissing to True if you want to store any data where there IS a match on the field name vs the key into
      the dictionary, and where there isn't a match, the problem is ignored.  If this value is left to False, the
      default, such a condition will trigger a KeyError exception, which will have to be trapped externally.

      :returns: Returns True on success, False on any kind of failure, in which case cErrorMessage and nErrorNumber will be
                set with explanatory values.

      Note that the dictionary returned by scatter() may be used as the first parameter of this method after you make
      any required changes to the field values.
      July 21, 2014 - Changed lbIgnoreMissing default to True. JSH.


   .. method:: _py2cbint(self, lnInt, lcTargetType)


   .. method:: _py2cbnum(self, lnNum, lcTargetType)


   .. method:: _py2cblog(self, lbBool, lcTargetType)


   .. method:: _removenonprint(self, xStr)


   .. method:: _py2cbtype(self, lxSourceValue, lcTargetType, lbForFilter=False)

      Utility function that converts Python variable (object) types to the string format needed for
      the CodeBaseWrapper function cbwGATHERMEMVAR() which optionally takes a string of character representations
      of the values for all fields.  [NOT required when you are using a dict() to supply data to gathermemvar.)

      lxSourceValue may be any legal Python value including string, int, float, Decimal, date, datetime, or bool.
      Other types will be coerced to a string value one way or another.

      Returns the string result of the conversion or "" when it throws up its hands and can't do anything, which is
      mainly on bad datetime values.

      NOTE!!!

      Unicode types in Python 2.x are not supported. Bytes and bytearray types likewise are NOT supported either
      in Python 2.x or 3.x.  Strings in Python 3.x which contain non-ASCII Unicode values likewise are NOT SUPPORTED.

      When working with these more modern types of data use gatherdict() and insertdict(), which perform
      sophisticated type and coding conversion consistent with the Python object type and the target field type.


   .. method:: convert_vfp_type(self, lcSourceValue, lcSourceType, lbStripBlanks)

      Converts a raw text string content of one field in a .DBF table to its appropriate Python type variable.

      *Since the development of the CodeBaseTools Python API module that quickly and easily returns native Python        objects for field values, there is limited use for this feature.  However, scatter and other functions        do offer a "no data conversion" for slightly enhanced speed, and those unconverted values can be        translated by this function when you are ready to use them in your program.*

      Note that for char (binary) and memo (binary) and any text fields containing Unicode data, you MUST        allow the CodeBaseTools module to do the conversions internally rather than using this function.

      Converts the field value information returned from the CodeBase engine into the appropriate native Python value.

      If you elect to have converttypes=False in copytoarray() or scatter(), you may want to use this method at some
      point to convert the raw values returned to native Python values.  But, to do so you'll need to determine the
      source field value type.  That can be extracted using the afields() method and inspecting the cType property
      of the appropriate field.

      :param lcSourceValue: Typically a string containing the physical representation of the field contents.  In            a few instances other types of values may be supplied, but the method figures that out.
      :param lcSourceType: One of the single-letter codes defining the field type, like 'C' for Character.
      :param lbStripBlanks: If True is passed (default is False), then a type 'C' field has the trailing spaced removed.

      Returns: the Python value (int, string, datetime, date, bool, etc.) or None on error.  Will also return None on
      empty DATE and DATETIME field values.


   .. method:: gatherdict(self, cAlias='', dData=None, coding='XX')

      Fast, modern alternative to gatherfromarray() (DEPRECATED) which updates the current record of the specified table
      with the data contained in the dictionary dData.  Will accept the optional alias name of a currently
      open table if you wish to store the data to a table that is not currently selected.  BE CAREFUL to make sure
      that the target table current record is the one you want to update.  Attempting to update a record
      in any table where there is no active record (either no records in the table or the record pointer at EOF)
      results in an error condition.

      Returns True on success, False on any kind of error.  Consult the error properties for reasons.

      Note that some types of errors will trigger Python exceptions.  These include passing illegal values
      to a field and passing field names that are too long or not of type string.

      Codes specify how string, bytes and bytearray objects are coded into field data.  XX is "default".  For
      details, see the docs for curval().  You can specify a conversion code for normal char and memo fields amd
      another code for conversions of char(binary) and memo(binary).  For type 'C', you can also set alternative
      codecs by setting the value of the default coding using setcustomcoding().

      June 22, 2020, changed third parm name from "codes" to "coding" to match other methods.


   .. method:: _dictcopy(self, xSrc)

      Produces a deep copy of the xSrc dictionary and returns a reference to the new dict.
      :param xSrc: any dict(), typically from a scatter() command
      :return: dict() or None if xSrc is None


   .. method:: copytoarray(self, alias='', maxcount=1000, fieldtomatch=None, matchvalue=None, matchtype='=', converttypes=True, stripblanks=False, fieldlist='', coding='XX', bDesc=False)

      Copies values of all (or selected) fields and all (or selected) records of the specified table into a list of dictionaries.

      If the optional parameter alias is left empty, the method works on the currently selected table.  Otherwise
      returns the contents of the open table with the alias name specified.

      The list will be in order as set for the requested table.  If no order is set, the ordering will be by record
      number.  Each element of the list object returned will be a dictionary consisting of one element for each field
      keyed by the field name.  On error will return an empty list.

      :param alias: If passed as an empty string, this function will apply to the currently selected open table, if            any.  Otherwise you may specify the alias name of a currently open table to output from.
      :param maxcount: By default, the function will return at most 1000 records (list items).  You can adjust this            maximum with this parameter.  Very large tables could result in out-of-memory conditions, however.  Set            this value to 0 for ALL records.
      :param fieldtomatch: You can restrict the output to selected records using three parameters.  This one specifies            the field whose value will be tested to determine if a record will be output.  Pass an empty string or            omit the parameter if you want all records.
      :param matchvalue: The value you want to test for the field defined in `fieldtomatch`.  Must be a value compatible            with the type of field specified.  Specifically the value must be of the following types for the specified            field types:

                         - Field type I (Integer) - int or long
                         - Field type C (Character) - string
                         - Field type D (Date) - datetime.date (None for empty date)
                         - Field type T (Datetime) - datetime.datetime (None for empty datetime)
                         - Field type N (Number) - int, long, float or decimal.Decimal
                         - Field type Y (Currency) - decimal.Decimal
                         - Field type M (Memo) - string
                         - Field type L (Logical) - bool (True or False)
      :param matchtype: Defines how the `matchvalue` parm will be tested against the value of the `fieldtomatch `.  Valid            values  are:

                        - "=" - Equals.  For string matches the comparison stops with the shorteer of the compared strings.
                        - ">=" - Greater than or equal to.
                        - "<=" - Less than ore equal to.
                        - "==" - Exactly equals.  Both test value and field contents must match exactly if strings.
                        - "<>" - Not equal.
                        - "$" - Contained in.  Equivalent of the Python 'in' operator.  The field value string must be                entirely contained in the `matchvalue` string.

                        NOTE - The string comparison rules described above are DIFFERENT from those that apply in the                expression for the locate() method.  This is due to differences in Python vs CodeBase handling                of equality expressions.
      :param converttypes: The default for this parm is True, which means that every field in the table will be converted            to its appropriate Python type in the output dictionaries.  You can avoid the processing overhead of this            conversion by setting this parameter to False, but you'll need to handle the conversion yourself.
      :param stripblanks: Applies only to C type fields which are stored with blanks padding them to the full width            of the field.  Defaults to False.  If set to True, then all C type fields will have blanks on the right            stripped off.  Does NOT apply to Memo fields.
      :param fieldlist: pass a comma delimited list of field names to this parameter to limit the number of fields            to your selected set.
      :param coding: Applies mainly to Python 3.x applications.  See the introductory docs for this class module for            details.
      :param bDesc: Pass True for the output to be in the current tag order but in descending, not ascending order.

      The reason for the filter mechanism is to allow very fast record filtering in the C component before Python
      ever sees the record values.  This can potentially eliminate significant numbers of records you just don't want
      to see.  Then you can perform tests on the resulting array to refine your search more precisely.  If you are
      using the client-server version of CodeBase, the filter test will be performed on the server before the data
      is actually retrieved across the network.

      :returns: Returns the list object which will be empty on error (len() of 0), in which case cErrorMessage and nErrorNumber
                will be set with explanatory values.  If the list is empty and you included values for fieldtomatch and
                matchvalue and if nErrorNumber = 0, your filter criteria didn't match any records.  With more recent versions
                of Python where dict() types are always ordered, the ordering will be in the order the fields appear in
                the table structure or in the order in the fieldlist parameter, if provided.

      ValueError will be raised if non-matching value types are passed as matchvalue or if a non-existing field name
      is passed.

      Sets the value of the tally property to the number of records added to the array.


   .. method:: _makefilterstring(self, lpcFld, lpcMatch, lpcRelate, lpcFldType)

      Internal method to make a filter string that CodeBase can use to evaluate a match for a current
      record.


   .. method:: replace(self, lpcFldName, lpxValue, coding='XX')

      Provides a quick and convenient way to replace the value of a field in the current record in any open table
      without worrying about selecting the current table.  Further, it takes any native Python type and properly
      stores it in the field, assuming that the Python type is compatible with the data field type.  See the
      documentation for field and value types for the matchvalue in copytoarray().

      To specify a field in any open table, prepend the field name with the table alias separated by a period.  For
      example for the last_name field of the employee1 table, set the value of lpcFldName to "employee1.last_name".

      To Replace() a date type field value with the VFP empty date, supply a value of 0, not None.

      Returns True on success, False on failure, and stores error info into cErrorMessage and nErrorNumber.

      The 'coding' parm added April 21, 2018.  See the class docstring for codes that define how string values will
      be converted for different text encodings. "XX" is the default coding.


   .. method:: replacelong(self, lpcFieldName, lpnValue=0)

      Very fast storage of a long value into a long field. Very little error checking.

      :param lpcFieldName: Field name with optional alias specification.
      :param lpnValue: Long value.  NO conversions are performed!!

      :returns: 1 on OK, else 0 or -1 on failure.


   .. method:: replacedatetimeN(self, lpcFieldName, lpnYear=0, lpnMonth=0, lpnDay=0, lpnHour=0, lpnMinute=0, lpnSecond=0)

      Very fast storage into a datetime field using numeric values for the components. Very little error checking.

      :param lpcFieldName: Field name with optional alias specification.
      :param lpnYear: The year number (3 or 4 digits).  Recognizes years back to 200 AD, but does not correct            for the conversion from the Gregorian to the Julian calendar.
      :param lpnMonth: Month number 1 to 12.
      :param lpnDay: Day of month number.
      :param lpnHour: Hours part of the time from 0 to 23
      :param lpnMinute: Minutes past the hour, from 0 to 59
      :param lpnSecond: Seconds past the minute, from 0 to 59

      :returns: 1 on OK, else 0 or -1 on failure.


   .. method:: closetable(self, alias='')

      Closes the currently open table or the table with the alias specified by the optional alias parameter.  Flushes
      all unsaved data to the disk and releases all the file handles.

      The table cannot be accessed again without another use() method, and references to this alias will fail.

      Returns True on success (table was open and is now closed) or False on failure (didn't find anything to close).


   .. method:: fielddicttolist(self, lxDict, lcAlias='', bPartial=False, cDelim='<~!~>')

      Transforms a record value dictionary as provided by the scatter() method to a list in the format required
      by the insertintotable() method, together with a field name string as required by that method as well.

      The first parameter is the dictionary.  The second parameter is the alias name of the target table which
      you'll be updating from the values in the list.  Note this parameter is required.  Returns a tuple consisting
      of the list of values as the first element and a delimited string list of field names in the correct
      order as the second element.
      bPartial:  Indicates the lxDict has only SOME of the fields.  Make sure ALL other fields are set.

      Note that the lxDict dictionary must have an entry for every field in the table, but it is NOT limited
      just to those values.  This allows you to build a dictionary with other information besides the required
      fields for whatever purpose in subsequent processing, and just use the fields required for the table when
      processing through this method.

      NOTE: This method is useful for supplying a list and a string of field names for the older version of
      insertintotable().  In this version of CodeBaseTools for Python, a dictionary of field values keyed by
      field name may be passed directly to insertintotable(), which uses the function insertintotableex() to
      pass the dictionary directly to the CodeBase engine.


   .. method:: closedatabases(self)

      Closes all open tables, flushes all pending writes to the disk, but keeps the CodeBase engine running.  Call this
      method when you are done with a bunch of work, but need to keep the object alive for additional work.  Any calls
      that require a currently selected table or an open table will fail after this has been called and until new calls
      to use().


   .. method:: createtable(self, lcTableName, lxFieldInfo)

      Method that creates a DBF type table, overwriting any pre-existing table of the same name.  Pass        the name of the table and an array of field info structures or a string containing field definitions.

      :param lcTableName: Is a string value containing a file name specification.  The name should have a '.DBF'            extension for compatibility with other programs that might access it; however, the .DBF extension is not            strictly required so long as you know what the file is -- these routines will open it again as a DBF file            if you pass its full name and extension to the use() method.
      :param lxFieldInfo: The second parameter to pass takes one of two different types of values:

                          - String - containing field specification information
                          - List - with each element containing an instance of a VFPFIELD object having information on one field.

                          The string version is the easiest to program.  It is a newline-delimited list of field specification                strings.  Each field specification string is a comma delimited set of field property values.                  The contents are in the form: <field name>,<field type>,<field width>,<field decimals>,<field allows nulls>

                              Example:
                              ::
                                  cField1 = "FIRSTFIELD,C,30,0,FALSE"
                                  cField2 = "SECONDFLD,C,25,0,FALSE"
                                  cStructure = cField1 + cNewLine + cField2

                          This would create a character field named FIRSTFIELD with a width of 30 bytes and would not allow nulls.                A second character field is defined and the strings are concatenated to form the structure definition.                For a brief list of field types see the doc for copytoarray().  For complete documentation on defining                fields in a DBF, see the CodeBase documentation and the types described in the docstring of this Class.

                          One field will be created in the table for each specification string, in the order listed.

                          Alternatively, you may supply a list of VFPFIELD objects each containing one field spec.  The properties of                each object must be set to define the field.  For example, for a VFPFIELD object vfx you might set:

                              Example:
                              ::
                                    vfx = VFPFIELD()
                                    vfx.cName="FIRSTFIELD"
                                    vfx.cType="C"
                                    vfx.nWidth=30
                                    vfx.nDecimals=0
                                    vfx.bNulls=False

      The most common use of this list of VFPFIELD type input is to obtain a list generated by the afields() method
      from a currently open table.  This allows you to easily create an exact empty copy of an existing table with just
      two lines of code, or by append to or deleting from the afields() result list, you can alter the table structure
      to fit your immediate needs.  Note that the elements of the VFPFIELD object class ARE type-specific.  For example
      the cName value MUST be a string, the nWidth value MUST be an integer.  You can also create VFPFIELD objects
      using the newfield() function.  These can then be appended into a list() for building a table structure.

      General rules:

          1) Field names must be 10 characters or less and start with a letter or underscore
          2) No two field names may be the same
          3) Maximum number of fields is 254 for VFP Compatibility (See limits documentation above)
          4) Maximum size (width) of a character field is 255 bytes
          5) Maximum size of a record is 65,500 bytes
          6) If you include one or more type 'M' fields (memo or large text) fields, a memo file will also            be created with the same base name as the table and an extension of .FPT
          7) In the Large Table Mode, the maximum values are substantially greater, see the Class docstring            on the Large Table Mode limits.

      Limitations:
          1) This version of CodeBase cannot read or update VFP tables with auto-incrementing Integer fields.
          2) Tables contained in a Visual FoxPro database container can be opened, but features derived from            the database container like long field names, triggers, validations, captions, etc., will not be            available.
          3) Tables will always be created in the Visual FoxPro FREE mode, meaning that they are not contained            in a database container.

      After the createtable() method finishes successfully, the newly created table will be empty and will be
      the currently selected table, opened in read/write mode, ready for appending records.  The alias of this
      table will be the base file name using the default alias naming rules when a specific alias is not provided.
      Be sure that there is no table open with that alias already, or that table will be automatically closed and
      possibly overwritten!  If you want the new table to have a custom alias, close it immediately using
      the alias() value passed to the closetable() method, and re-open it with your custom alias specified explicitly.

      :returns: Returns True on success, False on failure, in which case inspect properties cErrorMessage and nErrorNumber
                for an explanation.  Some errors such as invalid field names or other field characteristics will trigger
                a Python ValueError exception.  When a list is supplied, the CodeBasePYWrapper pyd module generates the
                Python exceptions, if required.

      NOTE: In some versions of Windows, it is recommended to close the newly created table immediately, and
      re-open it to ensure that all elements of the table are written properly to the disk.


   .. method:: appendblank(self)

      Adds a new, completely blank record at the end of the currently selected table.  Once the record is added
      you can call gatherdict() or replace() to fill data into the fields of the new record.

      Returns True on success, False on error, in which case check cErrorMessage and nErrorNumber for more information.

      Be careful when using this method on tables with a unique index which doesn't allow duplicate values for
      an index field into the table.  In that case, calling this more than once before replacing the indexed field
      with a unique value will result in an error condition as two records with a value of 0 in the indexed
      field would not be permitted.

      Adding a record with insertdict() is preferred over the successive calls to appendblank() followed by        getherdict() unless there is special processing that must be performed between those two actions.


   .. method:: dispstru(self, lbToText=False)

      Writes text to the stdout via a series of print commands which contains information about the structure of the
      currently selected table.  This is the equivalent of the VFP command DISPLAY STRUCTURE.

      Pass a True to lbToText and the function will return a string with this information.

      Returns True for OK and False on failure (usually because there is no currently selected table if lbToText is False.
      If lbToText is True, then returns the string on Success and an empty string on failure.


   .. method:: copyindexto(self, cSourceAlias, cTargetAlias)

      Takes two open tables and copies the indexes from the source table to the target table.  Removes the indexes        from the target table at the start.

      It is recommended that the target alias table be opened in Exclusive mode unless you are sure that there        cannot be any conflicts in opening the table.

      :param cSourceAlias:
      :param cTargetAlias:
      :return:  True on success, False on failure of any kind -- including if the target table doesn't have all        the fields found in the source indexes.

      NOTE: The target table must be a VFP "FREE" table NOT part of a database container.  Performing this method        on a target table in a database container will result in data corruption.  Source tables, however, may        be part of a VFP database container without problems, however PRIMARY KEY index tags may NOT copy correctly,        but CANDIDATE and UNIQUE indexes will.


   .. method:: copyto(self, cAlias='', cOutput='', cType='', cTestExpr='', bHeader=False, cFieldList='', bStripBlanks=False)

      Copies the contents of the specified table to another file, which may be one of 4 different types.

      It is similar to the VFP COPY TO command.

      :param cAlias: The alias name of the open table with contents to be written out.            If blank, the currently selected table will be used.
      :param cOutput: [REQUIRED] The fully qualified path name of the output file.  Be sure to include            the file name extension, as this function makes no assumptions about the output file name.
      :param cType: [REQUIRED] One of four string values: "SDF", "CSV", "TAB", "DBF", indicating:

                    - SDF = System Data Format -- Fixed width fields in records delimited by CR/LF
                    - CSV = Comma Separated Value -- Plain text with fields separated by commas
                      unless they are text, in which case, they are set off with double quote
                      signs thus: "joe's Diner","Hambergers To Go",35094,"Another Name".
                      If the text field has an embedded quote, the quote is transformed into a
                      double-double quote: "Joe's ""Best"" Hambergers","Pete's Grill".
                      Embedded line breaks within character/text fields are NOT supported.
                      If encountered, they WILL BE REMOVED from the data prior to output.
                    - TAB = Tab separated values.  Plain text with fields separated by a single
                      Tab (ASCII Character 9) character.  Character and number data is given
                      without any quotations other than what might exist in the data.  In
                      this implementation embedded line breaks in character fields and em-
                      bedded TAB characters in text fields are NOT supported and WILL BE
                      REMOVED prior to output of the data.
                    - DBF = Standard VFP-type DBF table.  Data structure will be identical to the
                      source unless a cFieldList is supplied.  No indexes will be copied.  Be SURE
                      to supply the file name extension as none will be assumed.
      :param bHeader: If True, then CSV and TAB outputs will include a first line consisting            of the names of each field, separated by the appropriate separator,            either Comma or TAB respectively.  Otherwise no field name data will            be included.  Default is False.
      :param cFieldList: A list of field names to include in the output.  If omitted, ALL            fields will be included (except as indicated in NOTES).
      :param cTestExpr: Text string containing a VFP Logical expression which must be True            for the record to be output.  If empty or null, ALL records are output.
      :param bStripBlanks: If True, trailing blanks will be stripped at the end of records.            Defaults to False.

      .. rubric:: Notes

      - For all types except DBF, fields which cannot be represented by simple text              strings without line breaks will be skipped.  These include types MEMO, GENERAL,              CHARACTER(BINARY), and BLOB.
      - In text formats Date fields will be output as MM/DD/YYYY or as specified by the current setting              of cbwSETDATEFORMAT().
      - In text formats Date-Time fields will be represented as CCYYMMDDhh:mm:ss, which is re-importable              back into CodeBase DBF tables via cbwAPPENDFROM().
      - The Deleted status of records will be respected based on the setdeleted() setting.
      - Current Order will be respected.
      - The TYPE of the file will be determined by the cType parameter regardless of the              name of the output file!!
      - The table named in the cOutput parm should NOT be open.  If it exists, it will be overwritten

      - Field lengths for the SDF type output are, in general determined by the length              of the data fields themselves.  Rules for length and output are as follows by              type:

          - C - Width of field.
          - D - 8 characters in the form YYYYMMDD
          - T - 16 characters in the form YYYYMMDDhh:mm:ss
          - L - 1 character ('F' or 'T')
          - N - Determined by size and decimals of field.
          - F (Float) - like N
          - B (Double) - 16 bytes, left-filled
          - I (Integer) - 11 bytes, left-filled
          - Y (Currency) - 16 bytes, 4 decimals, left filled.

      :returns: Returns number of records output or -1 on error.  Zero records returned may be a valid result,            if there are no records in the source table or none match the cTestExpr evaluation.

                If the function was successful, the new table will exist as specified but it will NOT be open.  If you            need to work with it, you will need to open it normally with the use() method after this method terminates.

      WARNING: If the output type is DBF and the base file name of the target table is the same as the source        table, then the alias of the source table MUST be a non-default string (not the same as the base table name).        The CreateTable() function, which is at the core of this function when outputting a DBF, creates the table        and opens it with the default alias name.  If that alias name is already in use, the original table is closed,        and the results will likely NOT be what you expect.

      KNOWN ISSUE: If you do a copyto() on a currently open table, and wish to repeat the process on that table        with a different target result, it may be necessary to close the source table and re-open it.  In some        instances, without this close, the repeat copy will create the target table but NOT put any records into it.


   .. method:: appendfrom(self, cAlias='', cSource='', cExpr='', cType='', cDialect='', cDelimiter='', cQuoteChar='', cFieldList='', bFieldsFromRow1=True)

      Copies records from an external source (.DBF or other type of file) into the specified open table.

      Works much like the APPEND FROM command in Visual FoxPro.  You specify a currently open alias as        the target, or pass "" or None, if you want to use the currently selected table as the target.  The        engine will attempt to append the data from the file cSource into that table.  It will select for the        append process only records which meet the cExpr logical expression if it is not "" or None.  NOTE: as        of this version, the cExpr filter is ONLY applied for DBF type source files.

      Four types of files can be the source: DBF tables, System Data Format (fixed position fields in a        text file using CR/LF separators for the records, CSV (comma separated values), and TAB/TXT (tab character        delimited values).  CSV and TAB/TXT file reading makes use of the Python csv library, which means that it        may be slightly slower to execute than 'C' native imports of DBF or SDF type files, but also means that there        is a great deal of flexibility in configuring the csv module to handle variations in CSV formatting.

      :param cAlias: Alias of open .DBF table to receive the new records.  Leave blank to use the currently selected            table.
      :param cSource: Full path name of the data source for records to be appended.  See note below for how            source types are guessed from the file name extension, but can be overridden.
      :param cExpr: A logical expression involving one or more fields being imported that must evaluate to True            for the record to be appended.  Only considered if source file is a .DBF type file.
      :param cType: Required field.  Must be one of the following: DBF, TXT, TAB, CSV, SDF.  See copyto() for             definitions.
      :param cDialect: supports the dialect options supported by csv.  Typically these are "excel" and "excel-tab", and            provide for reading csv or tab delimited (.TXT) files created by Excel.  Leave empty for native appendfrom()            processing or to override with the remaining parms.
      :param cDelimiter: define a character which separates fields in the input text string.  This defaults to "," (comma)            for native appendfrom() operations and 'excel' dialect.  For tab-delimited files, use "\t" (tab char), which            is also the default for 'excel-tab' dialect.
      :param cQuoteChar: the character used in the file to set off text strings, if any.  For native appendfrom() behavior,            this defaults to the double quote charcter: '"'.  Typically tab-delimited files don't use quote characters,            but some custom formats may.  By default, the csv handling of double quote characters embedded within text            fields is applied (it recognizes "" embedded in the string as a quote character).  For custom handling of            such situations, see customizing csv for your needs below.
      :param cfieldList: if the source data doesn't include field name information (see bFieldsFromRow1 or .DBF)            then you must supply a comma-delimited list of fields in the order they are found in the incoming            records.
      :param bFieldsFromRow1: Indicates whether the reader should look for field names in the first line of the input            file.  VFP does NOT support this feature, but csv DOES, and the default for appendfrom() behavior with            CSV or TAB/TXT input is for this to be True.  If you do NOT use this feature, then you have two options:            1) Supply cFieldList with a comma delimited text string containing one field name for each field in the            input table or 2) Be ABSOLUTELY CERTAIN that the target DBF table has exactly the fields you want in the            exact order as found in the input.

      Customizing csv for your needs:
          When this object class is created, the self.oCSV property is initialized            to an instance of csv.  That instance, configured to provide default behavior will be used for the            appendfrom() function.  However, if you configure your own csv instance and set custom dialect information            for it, you can use that by setting the oCSV attribute to a reference to your custom instance of csv.  See            the Python documentation for its csv.Dialect class for how to customize the format.  Alternatively, if            you know you'll always be wanting a particular Dialect configuration, then specify the properties of            Dialect on the self.oCSV object:

              - delimiter
              - doublequote
              - escapechar
              - lineterminator
              - quotechar
              - quoting
              - skipinitialspace

      If you set any one of these values to a non-None value, you'll need to set them all to meet your specific        needs, and no default Dialect information will be applied, and the parameters cDialect, cDelimiter,        cQuoteChar will ALL be ignored.

      NOTE: The default behavior of appendfrom() with CSV and TAB/TXT type files will correctly append files        created by the copyto() method of this class.

      Will use the file name extension of the source file to determine the type.  If that value is not "DBF" for        DBF table, SDF or DAT for System Data Format, or CSV for Comma Separated Values type, then you will need        to specify the type in the cType parameter as one of these 4 possible strings.  Since TAB is typically        not used as an extension for a tab-delimited file, you should expect to use the string 'TAB' for the        cType parameter and use .TXT or other appropriate extension for the file name.
      For SDF appends, the expected field widths for type C and type N fields are determined by the        table field sizes themselves.  However other field types like D, T, and B have special rules.  See        the documentation for the copyto() method for size rules for output to SDF from these fields.  This        appendfrom() method uses the same width assumptions for append from an SDF type file.  If these special rules        are not consistent with an SDF file supplied from another source, create a DBF table with all type C        fields and set the width of each to the corresponding width of each field in the source file.  After appending        from the SDF file, you can then copy from the resulting DBF table to one with the desired field types, making        conversions as necessary.

      :returns: The number of records appended or -1 on error.  Zero records is a potentially valid return if            for some reason the source table/file is empty or if cExpr matches no records..


   .. method:: insertintotable(self, lxValues, lcFields='', lcAlias='', lcDelimiter='<~!~>', coding='XX')

      Performs in one function the tasks of appending a new record to a table and filling the fields with new data.
      This approach requires that values for every field must be supplied in the lxValues parameter.  The rules for
      this field are identical to those for gatherfromarray() in the All Fields Mode.  This function does not suffer
      from the defects of the gatherfromarray() function in version 3.x of Python and is not deprecated.

      Unlike gatherfromarray() this method allows you to specify an alias name if you don't want to insert the
      data into the currently selected table.  Of course the table specified by alias must first have been opened
      by the use() method.

      Call this function repeatedly in a tight loop to add lots of records to the table.  Do NOT call flush() or
      flushall() until you are done.

      The lxValues field is where you pass field data to the method.  There are three forms this value may take.
      Depending on which form you supply, you may need to supply the lcFields parameter as well:

      1) Dict() should be keyed by field name with native python values for each field as the item value.  Do not
         pass any value for lcFields or an empty string.  lcDelimiter is ignored.  This is a fast, native Python
         field update.  In this form, you do not need to populate the dict() with every field in the table,
         just the ones you need to update.  However, be sure to pre-populate any primary keys that must be
         unique!

      2) String should contain a delimited text representation of the contents of each field.  Either all fields must be
         supplied in the correct order as in the table, or supply a list of field names in the appropriate order
         in the lcFields parameter.  The lcDelimiter value should be used for both.  See the gatherfromarray()
         doc string for details on how strings should be formatted for logical, date and other non-text fields.

      3) List() containing one element for each field you want to update.  In this case you MUST supply an
         element of the list for every field in the table in the correct order.

      Returns True on Success, False on error.


   .. method:: insertdict(self, dDict, lcAlias='', coding='XX')

      Simple version of insertintotable() that just takes a dict() of field names and values and inserts
      the data into the specified lcAlias table or the current table if it's empty.  Returns True on OK,
      False on any error.  Synonymous with insertintotable() with a dict() parm, but simpler calling
      signature and slightly faster performance.

      For coding specifies txt string conversion rules for text and binary data.  See class docstring for
      details of alloable codes.


   .. method:: setdeleted(self, lbHow=None)

      This function sets the DELETED status for all table access.  If DELETED ON or TRUE is set by passing a
      value of True to the method() then most table navigation methods will automatically skip over deleted
      records.  When this module is initialized, the status is set to DELETED OFF in which case all records
      are visible regardless of deleted status.  To turn DELETED OFF, pass a False to the method.  This may be done
      at any time and will affect all future table navigation until changed.

      Again, note that this follows the FoxPro convention where the DELETED ON status tells the data engine to
      ignore deleted records (Delete testing is ON).  When DELETED OFF has been set in VFP, all records, including
      those on which the deleted flag has been set to TRUE are visible.

      For most normal operations, you will want to issue a setdeleted(True) command to ensure that you don't
      have to test constantly for the deleted() status of every record.

      The DELETED status affects all skip() functions and goto() functions except for those where you goto()
      a specific record number.  In that case you will still need to test the deleted() status.

      Also, the copytoarray() method adheres to the DELETED status.

      If you pass None as the parameter lbHow, then the function returns the current state of the DELETED flag:
      True for DELETED is ON, False for DELETED is OFF.  Otherwise, always returns True.


   .. method:: delete(self)

      Marks the current record of the currently selected table for deletion.  Does not move the record pointer
      even if DELETED is set ON.

      Returns True on success, False on failure, in which case cErrorMessage and nErrorNumber will provide more
      information.


   .. method:: flock(self, retries=0, interval=0.1)

      Locks the currently selected table.  This allows you to safely update multiple records or collect statistics
      about the contents of a table without risk of other processes changing the contents.  Also if you cannot place
      the flock() and can afford the time, pause for a few milliseconds and then try again.  You can do this
      explicitly by specifying a number of retries in the retries parm and an interval specified in fractions of a
      second (default is 0.1 seconds).


   .. method:: rlock(self, retries=0, interval=0.1)

      Locks the currently selected record of the currently selected table.  This allows you to safely update
      the contents of the record either by a replace() or a gatherdiect().

      This method plus its corresponding one unlock() gives you the added measure of certainty relative to
      the record updating process.  If activity in the target table is light, with few other users making updates,
      it is not necessary to call rlock() explicitly.  After your field value updates, CodeBase waits until you move off
      the record or call flush() to lock the record, write the data to the file, and then automatically unlock the
      record.  Typically, this works without a hitch.  But in situations where there is a lot of save activity it
      can happen that it is impossible to obtain the lock, and an error is reported from the record move or flush.

      To avoid that possibility, the sequence would be:
          - navigate to the record with seek(), skip() or goto()
          - scatter() the field values so you can work with them in your program
          - when you are ready to save changes back to the record, call rlock()
          - if rlock() returns True, you can call replace() or gatherdict() to make the changes
          - if rlock() and the update was successful, call flush()
          - call unlock()

      Returns True on Locked OK, False if unable to get lock for any reason.

      Note: Leave the rlock() in place as short a time as possible.  Also if you cannot place the rlock() and can
      afford the time, pause for a few milliseconds and then try again.  You can do this explicitly by specifying
      a number of retries in the retries parm and an interval specified in fractions of a second (default is
      0.1 seconds).


   .. method:: unlock(self)

      Unlocks the current record of the currently selected table.  See rlock() for more information.  Returns True
      on success, False on failure.  Also is used to remove the table lock applied by flock().


   .. method:: pack(self)

      Pack performs the VFP PACK function which copies all records NOT marked
      for deletion to a temporary table, then empties out the table, and
      copies the surviving records back into it. This method performs that
      task on the currently selected table.

      The VFP rule that this can only be performed on a table opened
      exclusively is NOT enforced in this module, but if it is expected that
      other users might access the table, then a use() with the exclusive
      option should be done before applying a pack().

      One of the side effects of a pack() is that memo files (the .FPT file)
      storing memo field data, are restructured, which usually produces a
      smaller file.

      Returns True on success, False on failure of any kind. A typical error
      would be that there is no currently selected table.


   .. method:: reindex(self)

      Call this method to refresh the indexes on the currently selected table.

      Normally indexes in CDX index files (the Visual FoxPro standard) are updated automatically by this module
      as they are by VFP when changes are made to the table.  However, after a while the index pointers can become
      inefficiently arranged, and a reindex can possibly improve performance on large (over 1mm records) tables.

      Returns True on success, False on failure of any kind.

      Note: If it is possible that other users will be accessing the table you wish to reindex, it is best to
      use() the table with the exclusive=True parameter so as to prevent index corruption and data retrieval
      errors by the other users.


   .. method:: scan(self, indexTag='', forExpr='', noData=False, fieldList=None, getList=False, stripblanks=False, bNoTop=False, bDescending=False, coding='XX')

      Functions as an iterator that can be used for successively returning rows from the currently selected table
      either as dictionaries, similar to scatter() which returns a dictionary for the current record, OR
      as a list of values as from scattertoarray() if you pass getList as True.  Note that the items in the
      returned list() will be either in the order the fields appear in the table or, if fieldList was passed,
      in the order found in the fieldList string.

      Call as:
          for xx in xcbTools.scan(indexTag="MyTag", forExpr="FIRSTNAME='John'")
              print xx["FIRSTNAME"], xx["LASTNAME"]

      Returns None on error and when done.  Note that if forExpr is provided (non blank) the iteration
      will stop when there are no more records matching the forExpr.  If the indexTag value (or the currently
      selected index tag) has an expression exactly matching the left hand side of the forExpr, then the iteration
      may stop before an actual EOF() condition is reached.  Otherwise when the iteration is completed, the table
      record pointer will be positioned at EOF().

      noData parameter:  This returns a record number rather than the scattered contents of the entire record.
      Use this if you just want a few fields and don't want to waste the time for parsing the full record.

      Support for temporary indexes:  If you want to scan in order by a temporary index, create the index
      and then when scanning pass "" or omit the indexTag parameter.  Your temporary index ordering will apply
      to the scan.  Specifying a different tag in the scan will substitute that ordering even if one or more
      temporary indexes exist.

      The  parameter fieldList is an optional comma-delimited list of field names.  If it is non-blank and if
      noData is False, then the returned dict() or list() ONLY has the fields listed in the fieldList.  This allows fast
      in-dll retrieval of field values even when you only want a few of the many fields in the table.

      By default, this function starts the scan at the beginning of the table, based on the currently set or
      specified index tag (or by recno, if no tag is active).  Pass bNoTop=True to override this behavior, and to
      start from where the record pointer is currently positioned.  If bDescending is True, then by default goes
      to the bottom of the table.  bNoTop is respected by not going to the bottom first in this case.

      If bDescending is True, then the scan moves backward through the table in the specified order.

      NOTE: Nested scans are NOT supported.  seek() is supported into another table in the middle of the scan.


   .. method:: zap(self)

      Removes all records from the currently selected table.  This is more drastic than deleting all records
      because the table is actually reconstructed from scratch with no records.  All existing records will be
      lost.  USE WITH CARE.  There is NO WARNING MESSAGE.

      Use on a table that has not been opened in exclusive mode is extremely risky.

      Returns True on success, False on failure.


   .. method:: xmltocursor(self, cAlias='', cXML='', cFileName='')

      In VFP the XMLTOCURSOR() function is the converse of the CURSORTOXML() function.  It makes possible the loading
      of XML created by CURSORTOXML() back into a cursor.  This replicates a portion of the functionality of the
      VFP function.  In this case, the xml data will be stored back into a table (appending the records) which
      has some or all of the fields specified in the xml data.  It will be up to you to make sure that if the
      table has primary keys, which must be set externally to unique values, that those will be handled somehow.
      No capability is provided to create a table into which to load the XML (as is provided for in VFP), so you
      must first create a table to receive the XML records, and have field names which correspond.

      The primary tag name for the XML data is typically <VFPData> but may be something else.  Tag names for
      individual records may be any value.  Tag names for fields must match the spelling (but not the case) of fields
      in the target table, or the data element will be ignored.

      :param cAlias: Alias of an open table.  If blank, the currently selected table will be used.
      :param cXML: Text string with the XML content to be loaded.  Leave "" if loading from a file.
      :param cFileName: File name from which to load the XML.  Leave "" if cXML is passed.
      :return:  Number of records loaded.  0 indicates an error.


   .. method:: cursortoxml(self, cAlias='', cForExpr='', cFields=None, bStripBlanks=False, cFileName='', cpRecName='', cAltMainTag='')

      In VFP the CURSORTOXML() function is a powerful means of copying all or part of a cursor or table into
      XML form in several different ways.  This method provides a subset of that functionality, creating a file
      that is identical to the default VFP output where each record has a tag, and each field in that record has
      its tag and the corresponding value contained in the tag.  The top-level tag name is always <VFPData>.  All
      field and cursor record tags are lower case.  Outputs fields in each record in the order in which they
      appear in the table or in the order in the cFields list. See also xmltocursor().

      :param cAlias: Pass the alias name if not the currently selected table.
      :param cForExpr: Pass a valid logical expression to select records.  If omitted, all records will be output
      :param cFields: Pass a comma delimited list of field names to limit the output to selected fields.
      :param bStripBlanks: By default, trailing blanks on text fields are left in place.  Set this true to trim them
      :param cFileName: Pass a file name to output the result directly into that text file.  If omitted, then
          the method will return the resulting XML as a string
      :param cpRecName: Each record output will be set off in a repeating tag name.  If a value is provided for
             this parameter, it will be used for that repeating tag name, otherwise the system will generate a
             unique 8-character name in all lower case for the record tags.
      :param cAltMainTag: By default this function follows the VFP practice and wraps everything in <VFPData> tags.
             If you want something different, specify the base name here.  The system will add the brackets.
      :return: The XML text as a string unless the cFileName parm is not empty.  If cFileName is "", if an error
          occurs, the function will return "".  If cFileName is a file name, returns True on success, False on
          failure, and sets cErrorMessage.

      NOTE: The XML text is stored in memory until output at the end.  Very large tables may produce memory
      issues as a result, especially in 32-bit versions of Python.


   .. method:: getValueFromXMLString(self, cValue, cType)

      Utility function that takes an XML value in standard VFP output format, and returns the Python native type
      corresponding to the field type specified in the cType parameter
      :param cValue:
      :param cType:
      :return: Native Python value or None on error.


   .. method:: makeXMLValueString(self, xValue, cType)

      Utility function that transforms a field type into a text value string for cursortoxml() output.
      :param xValue: Any legal python value
      :param cType: The official type of the database table from which it comes.
      :return: Text string of the value to put into the XML block


   .. method:: getNewKey(self, dataDir, filename=None, readOnly=False, stayOpen=False, noFlush=False)

      Returns the next sequential unique key number for the passed filename or a negative
      value on error.  Using this method provides an alternative to auto-incrementing keys which CodeBase
      supports in a manner incompatible with Visual FoxPro.

      :param dataDir: cDataDirectory from configurator.  If NEXTKEY.DBF is not open and this is blank, triggers an            exception.  This is where the NEXTKEY.DBF table should be found if the method has to open it.
      :param filename: name of file to get next key.  Defaults to *current*, but if no current and blank, triggers            an exception.
      :param readOnly: if set, return *previous* key number, write nothing - (for testing) - NOT USED!
      :param stayOpen: if set, does not close NextKey.dbf when done.  For looping and testing.  For maximum speed when            using this function to add many records in a loop, open the NEXTKEY.DBF table prior to starting the            loop.  This function will then not try to open it every time it runs.
      :param noFlush: By default the method flushes the contents of the NEXTKEY.DBF table to disk using the OS flush            to disk command to make sure that any other users see the updates immediately. However, if that            won't be needed for operational requirements, this function can be speeded up by more than a            factor of 10 by passing noFlush=True, to bypass this flushing action.  In that case, you may still            wish to issue a flush() function at the end of your looping update process.

      NOTE: CodeBase claims to support auto-generated key fields, but that functionality doesn't appear to be
      compatible with the corresponding feature in Visual FoxPro.  This function helps get around that limitation
      by using a NextKey.dbf table to store the "next key" value of each table in your system.  The NextKey.dbf
      table is expected to have two fields at minimum:

      +-----+------------+-----------+------+----+------+--------+------+
      |Field|Field Name  |Type       |Width |Dec |Index |Collate |Nulls |
      +=====+============+===========+======+====+======+========+======+
      |  1  |TABLE_NAME  |Character  |  20  |  0 | Asc  |Machine |   No |
      +-----+------------+-----------+------+----+------+--------+------+
      |  2  |NEXTKEYVAL  |Integer    |   4  |  0 |      |        |   No |
      +-----+------------+-----------+------+----+------+--------+------+

      It will need to have an index called TABLE_NAME on UPPER(TABLE_NAME).  The dataDir parameter tells the function
      where to find the NextKey.dbf table.  This function uses record locking to ensure that no keys are duplicated
      within the same table.

      It is the responsibility of the programmer to know which field is the key field in the table and to do
      the replace of the value generated by this function into the appropriate field in the table.


   .. method:: setstrictaliasmode(self, bMode=False)

      Obsolete, but here because some old code may make this call

      Contact MPSS if you have issues with long alias names and are using older versions of
      CodeBaseTools c4DLL.DLL.  The version of the DLL found on the Open Source area in GitHub has
      a bug fix that eliminates the necessity of this work around.


   .. method:: openTableList(self, aTables, cPath='')

      Pass this a list of values each consisting EITHER of a string containing a comma or space delimited
      list of table names OR a list of tuples consisting of (tablename, readonly, alias).  Then the method
      will attempt to open all tables, set each to the specified readonly status, and assign the
      specified alias.  All three elements of each tuple must be passed, but they may be passed as None
      or "".  In that case the default readonly will be False, and the normal alias will be assigned.  The
      same defaults will apply if the aTables value is a string of table names.

      If one of the tables is to be opened exclusively, the readonly element of the tuple must be passed as
      the text string "EXCL".

      Returns a list of the aliases, in the same order as the tables originally passed.  Returns None on
      error, in which case you can inspect the cErrorMessage property for the reason why.  If None is returned,
      NONE of the tables will be opened.  Any opened partway through the process will be closed before the return.

      If cPath is non-empty, it will be prepended to each of the table names to make the full path name of
      the table to be opened.  Otherwise you'll need to put the fully qualified path name of each table
      in the list of tuples.



.. function:: cbTools(bIsLarge=False)

   Factory function that delivers an object reference to the _cbTools() type object.    Note that by default this module serves up only ONE actual copy of the _cbTools() object.    Subsequent calls return an object reference to the same original instance.

   :param bIsLarge: Default is False, which produces an object which can co-exist with Visual FoxPro in accessing        tables simultaneously, but limits tables to VFP type limits (max size 2GB).  Pass True for a version        that enables Larget Table mode to access tables of almost unlimited size.

   :returns: Object reference to a _cbTools() class object.


.. function:: cbToolsX(bIsLarge=False)

   This version of the cbTools caller creates a brand new instance every time.  This is preferred for new work    because it provides for a unique session number for the instance to reduce interference between instances    in opening and closing tables.  Should work fine with TableObj type routines as well as legacy methods.
   Added Dec. 2, 2014. JSH.
   :param bIsLarge: See cbTools() for details.

   :returns: The object reference to a new instance of cbTools()

   NOTE: While Codebase does assign each instance a unique data session number, the opening and closing of    tables is not really isolated, despite what their docs claim. Oct. 7, 2015. JSH.

   NOTE: This version is experimental.  The unique instances do not appear to be as individually isolated    as the CodeBase docs suggest they should be.


.. py:class:: TableObj(vfp, tablename, alias='', readOnly=False, exclusive=False, reset=False)

   Bases: :class:`object`

   Treat vfp table access as if separate objects for each table.
   'reset' keyword will close/reopen file to flush file buffer  (still requires full path in tablename)
   opens with 'setdeleted' True, so deleted records are ignored by default

   NOTE: It is recommended that you do NOT instantiate this object yourself in your code.  Instead,
   create an instance of cbTools() and then create table objects using the factory method of that class named
   TableObj().

   For details on how this component works, see the docstring for the TableObj() method in cbTools().

   .. method:: __getattr__(self, fieldName)

      Allows getting VFP fields AND methods via i.field_or_method_name        does not change current active file when only accessing field names.        DOES change current active file when using CodeBaseTools methods        current selected table is NOT reset on error or method call


   .. method:: __setattr__(self, fieldName, value)

      allows setting VFP fields with i.field_name = new_value
      does not change current active file unless an error occurs


   .. method:: __getitem__(self, fieldName)

      allows retrieving VFP fields with i[field_name]


   .. method:: __setitem__(self, fieldName, value)

      allows setting VFP fields with i[field_name] = new_value


   .. method:: __repr__(self)

      Return repr(self).


   .. method:: __str__(self)

      Return str(self).


   .. method:: __iter__(self)

      simple iterator to loop through records.  Works with indexes as in the two examples below:

      Example:
      ::
          for r in fileInstance:
              print r.doc_code

      Example:
      ::
          [r.doc_code for r in fileInstance if r.doc_reqd]

      :return: generator


   .. method:: _saveName(self)

      If the "current" VFP table isn't the the one we want, switch to the one we want, then return the...
      :return:  string name of the previous "current" VFP table


   .. method:: close(self)

      closes table AND renders instance inert.
      does not change current active file


   .. method:: newId(self)

      return next unique ID.
      does not change current active file
      NextKey file should be already opened


   .. method:: next(self)

      next record.
      does not change current active file


   .. method:: reset(self)

      close and re-open file.
      does not change current active file



.. function:: copydatatable(cTableName='', cSourceDir='', cTargetDir='', bByZap=False, oCBT=None)

   Function which copies all files for one DBF type table from one directory to another.
   Takes 5 parameters:
   - Name of the table, no path, extension optional unless NOT .DBF
   - Name of the source directory - fully qualified
   - Name of the target directory - fully qualified
   - By Zap, which causes table content to be removed and replaced
   - oCBT which is a handle to a CodeBaseTools object, if an external one is to be used.

   Returns True on success, False on failure.  If there is an existing table in the
   target directory, it and its related files are renamed to a random name prior
   to the copy process and then copied to an ARCHIVE subdirectory.  If failure,
   the partially copied files are removed and the originals renamed to their starting names.
   On returning False, writes the error into the gcLastErrorMessage global.
   In that case call getlasterrormessage() to retrieve the description of the error.
   As of 12/29/2013, this method will attempt to copy by zapping the contents of the
   target table and appending in the source, if the bByZap parameter is True.  If failing
   that or if bByZap is False, then copies using the operating system copy functions.
   Caller should provide a CodeBaseTools object as oCBT or this program will create its own.
   Note that if the source table is in a VFP database container, and if the function
   uses the OS to copy the file, the resulting copy will have a reference to the database
   container in it, which may not be what you intended.


