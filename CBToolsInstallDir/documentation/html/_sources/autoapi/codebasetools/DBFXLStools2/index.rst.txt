:mod:`codebasetools.DBFXLStools2`
=================================

.. py:module:: codebasetools.DBFXLStools2

.. autoapi-nested-parse::

   ------------------------------------------------------------------------
   DBFXLStools2 Module - Convert .DBF to Excel and Excel to .DBF tables
   ------------------------------------------------------------------------
   The power and convenience of accessing, manipulating and assembling data using CodeBaseTools is combined here
   with the convenience and universal acceptance of the .XLSX Excel spreadsheet format for sharing and displaying data.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   codebasetools.DBFXLStools2.DbfXlsEngine



Functions
~~~~~~~~~

.. autoapisummary::

   codebasetools.DBFXLStools2.addExt
   codebasetools.DBFXLStools2.quickExcel2DBF
   codebasetools.DBFXLStools2._dtTest


.. data:: __author__
   :annotation: = J. S. Heuer

   

.. data:: d2xConvertFrom
   :annotation: = NYCDTILMBFGZW

   

.. data:: d2xConvertTo
   :annotation: = NNSDDNLSNNXSX

   

.. data:: x2dConvert
   

   

.. data:: cErrorMessage
   :annotation: = 

   

.. data:: _ver3x
   :annotation: = False

   

.. function:: addExt(name, ext='dbf')


.. py:class:: DbfXlsEngine(oVFP=None)

   Bases: :class:`object`

   DbfXlsEngine provides a suite of methods to copy data from DBF tables to Excel files and the reverse.  It requires
   the installation of the ExcelTools module and the CodeBaseTools module.  Note that the ExcelTools module requires
   a licensed version of LibXL and the LibXLWrapper.dll.  LibXLWrapper.dll is an open source module that is part
   of the ExcelTools distribution, but LibXL is a commercial product requiring a user name and license code to
   be stored in a libXLLicenseInfo.txt file.  See the documentation for ExcelTools for more details.

   The normal usage for this object is to pass it an object reference to an instance of cbTools() from the
   CodeBaseTools module:

       oEngine = DbfXlsEngine(cbTools())

   But, if no cbTools instance is supplied, one will be created if possible, providing this is invoked via the
   "with" mechanism.  See the dtTest() function for an example of this usage.

   .. method:: __enter__(self)


   .. method:: makeHeaderFormat(self)

      Format creator for the column header cells containing the field names.
      :return: Format Object


   .. method:: makeHeaderFormatXLSX(self)

      Format creator for the column header cells containing the field names.  Uses default fonts from
      XLSX type files.
      :return: Format Object


   .. method:: makeBodyHiddenFormat(self)

      Format creator for the cells in a hidden row.  The hidden row option allows the raw DBF field names to
      be included in the XLS file without actually displaying them -- the column headings can then display
      human readable names.
      :return: Format Object


   .. method:: makeTitleFormat(self)

      Format creator for the top-of-the-page title if one is to be displayed.
      :return: Format Object


   .. method:: makeBodyFormat(self)

      Format creator for the standard body cells containing data displayed in text format (including dates)
      :return: Format Object


   .. method:: makeBodyDecimalFormat(self)

      Format creator for the standard body cells containing data in numeric format.  Defaults to 2 decimal places
      and the standard thousands separator character.
      :return: Format Object


   .. method:: makeBodyFormatXLSX(self)

      Format creator for the standard body cells containing data displayed in text format (including dates).
      This version uses font types standard for XLSX files.
      :return: Format Object


   .. method:: makeBodyDecimalFormatXLSX(self)

      Format creator for the standard body cells containing data in numeric format.  Defaults to 2 decimal places
      and the standard thousands separator character.  This version uses font types standard for XLSX files.
      :return: Format Object


   .. method:: calcColumnWidth(self, lcType, lnWidth, lnOverride=0.0)


   .. method:: bizobj2excel(self, oBiz=None, cExcelName='', xHeaderList=None, cTitleOne='', cTitleTwo='', bHiddenNames=False, bNoClose=False, cFieldList='', cForExpr='', cSortOrder='')

      NOTE: This method is intended to work with MPSS, Inc., standard business object class wrapper for data
      tables (either .DBF or MongoDB).  The MPSS business object class is NOT provided as part of the CodeBaseTools
      module.  Contact MPSS, Inc., for more information.

      Similar to dbf2excel except that takes as input a fully configured biz object with a table attached.  This
      can be a Biz Object for either a DBF or a MongoDB table.  This pulls all the data out with a copytoarray()
      call, then stringifies the data for storing into the cells and outputs the specified Excel.  Outputs ONLY
      .XLSX files, although that may be slower than .XLS.

      :param oBiz: Object reference to the MPSS BizObject which will be the source of the records
      :param cExcelName: Fully qualified path name for the Excel output file.  Will be forced to ext of .XLSX
      :param xHeaderList: List() object with one text string for each column of output
      :param cTitleOne: Optional title for first row
      :param cTitleTwo: Optional title for second row
      :param bHiddenNames: If True, then we'll output a hidden row with the field names directly after the title row.
      :param bNoClose: Ignored
      :param cFieldList: Comma separated list of field names that will be output and in the order listed.
      :param cForExpr: If not all records are to be output, specify a legal "for" expression here.  This will be            passed to the Biz Object to restrict the list of records in the copytoarray() call
      :param cSortOrder: Pass the name of a DBF index TAG or the name of a MongoDB field to control the sort order.

      :returns: True on Success, otherwise False, and set the error message.


   .. method:: dbf2excel(self, lcDbfName, lcExcelName, headerlist=None, titleone='', titletwo='', rawcopy=False, hiddenNames=False, noclose=False, fieldList='')

      Copies the contents of the specific DBF file into the spreadsheet named lcExcelName.
      If the spreadsheet already exists, it is overwritten.  Otherwise it is created.  There
      will be a header row containing field names and one row following that for each table
      record (row).

      If headerlist is of type list(), it should contain one text value for each column in the table/sheet.
      These text values will replace the field names in the top row. (In that case, the output can't be used
      for import back into dbf via excel2dbf().

      If titleone and/or titletwo are non-empty strings, they will be placed in A1 and A2 respectively
      in 12 point Bold, and all content will be moved down accordingly.

      Data table fields will be properly converted to Excel value types.

      Fields such as General will not be converted.  Memo will be included.

      If you are confident you know that all fields in the table are convertable to Excel types (for example
      that there are no "General" or "Memo-Binary" fields in the table), then you can use the rawcopy option
      which does no type or content checking other than the standard conversions from VFP to Excel formats
      for dates, etc.  Pass the optional parameter rawcopy=True in that case.

      Table ordering is by record.

      If hiddenNames == True, then inserts a row directly below the title row (either containing the
      field names or the values in headerlist) which will be filled with the field names AND be set to
      hidden.

      Returns True on success.  False on Failure.


   .. method:: setdbfstru(self, lcFieldVals, lcFieldTypes, lxDbfTypes, lxDbfWidths, lxDbfDecimals)


   .. method:: excel2dbf(self, lcExcelName, lcDbfName, sheetname='', appendflag=False, templatedbf='', fieldlist=None, columnsonly=False, showErrors=False)

      Writes the contents of the specified Excel file (xls or xlsx) into the target DBF type table.  The existence of the
      lcDbfName table and the appendflag value determine the action taken:

      lcDbfName exists, appendflag = False:
          - lcDbfName records are removed (zapped), all records are replaced with newly imported records.  Any value in templatedbf
            is ingnored.
      lcDbfName exists, appendflag = True:
          - Records from the spreadsheet are appended into the table after the existing records.  Any value in templatedbf
            is ignored.
      lcDbfName doesn't exist -- appendflag has no meaning:
          If templatedbf contains the name of a valid DBF table, then uses the structure of that table to create a new table
          and imports data into it.
          If templatedbf == "" or None, then inspects the contents of the spreadsheet and creates a table the best way it can
          from the cell information.

      Takes the data from the first worksheet in the workbook.  You can pass a worksheet name to use instead in the
      sheetname optional parameter.  Note that in Excel, worksheet names are case sensitive.

      If the templatedbf parameter contains the name of an existing DBF type table, then appendflag is ignored and
      a new table is created (overwriting any existing one by that name) using the identical structure of the template
      DBF table.

      You can supply a list() of field names to include in the output DBF table.  In that case, the fields in the output
      table consist of those that are BOTH in the spreadsheet AND in the fieldlist.  If appendflag == True, the fieldlist
      will be respected -- records will be appended to the lcDbfName table, but only the fields specified will be populated.

      The first row of the spreadsheet must contain text values that are valid field names.  No more than 255 are permitted.
      Field names may be upper or lower case but MUST start with a letter or underscore.  They may be no longer than 10 characters
      and may NOT include blanks.  No two field names may be the same.  Any violation of these rules will result in an error flag
      being returned.

      Returns the number of records stored or appended.  Returns -1 on error, however if 0 is returned, you likely should investigate
      the source of the problem.

      NOTE: The CodeBase utilities are fairly slow in creating new DBF tables.  Not sure why.  At least the first one they create
      seems to take around 0.45 seconds on a very fast machine.  The second and third are faster, however.  So... for simple things
      just let this method write into an existing table, for much better performance.


   .. method:: __exit__(self, lcClass, lcType, lcTrace)


   .. method:: __del__(self)



.. function:: quickExcel2DBF(cSourceXLS='', cDestDBF='')


.. function:: _dtTest()

   For internal testing ONLY
   :return:


.. data:: bResult
   

   

